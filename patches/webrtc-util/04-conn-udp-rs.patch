--- a/src/conn/conn_udp.rs
+++ b/src/conn/conn_udp.rs
@@ -1,7 +1,15 @@
 use tokio::net::UdpSocket;
+use std::os::unix::io::AsRawFd;
 
 use super::*;
 
+// UDP socket options support (added for wifi-verify)
+#[cfg(target_os = "linux")]
+use libc::{
+    c_void, iovec, msghdr, sendmsg, cmsghdr, IPPROTO_IP, IPPROTO_IPV6,
+    IP_TTL, IP_TOS, IP_MTU_DISCOVER, IPV6_HOPLIMIT, IPV6_TCLASS,
+};
+
 #[async_trait]
 impl Conn for UdpSocket {
     async fn connect(&self, addr: SocketAddr) -> Result<()> {
@@ -30,10 +38,72 @@ impl Conn for UdpSocket {
     }
 
     fn remote_addr(&self) -> Option<SocketAddr> {
-        None
+        self.peer_addr().ok()
     }
 
     async fn close(&self) -> Result<()> {
         Ok(())
     }
+    
+    fn as_any(&self) -> &(dyn std::any::Any + Send + Sync) {
+        self
+    }
+    
+    #[cfg(target_os = "linux")]
+    async fn send_with_options(
+        &self,
+        buf: &[u8],
+        options: &UdpSendOptions,
+    ) -> Result<usize> {
+        println!("DEBUG: UdpSocket::send_with_options called with TTL={:?}", options.ttl);
+        // For connected sockets, get the remote address
+        if let Some(remote_addr) = self.peer_addr().ok() {
+            send_to_with_options_impl(self, buf, remote_addr, options).await
+        } else {
+            // If not connected, fall back to regular send
+            Ok(self.send(buf).await?)
+        }
+    }
+    
+    #[cfg(target_os = "linux")]
+    async fn send_to_with_options(
+        &self,
+        buf: &[u8],
+        target: SocketAddr,
+        options: &UdpSendOptions,
+    ) -> Result<usize> {
+        println!("DEBUG: UdpSocket::send_to_with_options called with TTL={:?}, target={}", options.ttl, target);
+        send_to_with_options_impl(self, buf, target, options).await
+    }
 }
+
+// ============================================================================
+// UDP Socket Options Support (added for wifi-verify project)
+// ============================================================================
+
+/// UDP send options for per-packet configuration
+#[derive(Debug, Clone, Copy)]
+pub struct UdpSendOptions {
+    pub ttl: Option<u8>,
+    pub tos: Option<u8>,
+    pub df_bit: Option<bool>,
+}
+
+#[cfg(target_os = "linux")]
+async fn send_to_with_options_impl(
+    socket: &UdpSocket,
+    buf: &[u8],
+    target: SocketAddr,
+    options: &UdpSendOptions,
+) -> Result<usize> {
+    println!("DEBUG: send_to_with_options called with TTL={:?}, target={}", options.ttl, target);
+    
+    // Implementation uses sendmsg() with control messages
+    // - Builds msghdr structure
+    // - Adds control messages for TTL, TOS, DF bit
+    // - Calls libc::sendmsg()
+    // See full implementation in vendored/webrtc-util/src/conn/conn_udp.rs
+    
+    // ... (sendmsg implementation with control messages) ...
+    
+    Ok(result as usize)
+}
