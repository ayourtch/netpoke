use serde::{Deserialize, Serialize};
use wasm_bindgen::JsCast;
use wasm_bindgen::JsValue;
use wasm_bindgen_futures::JsFuture;
use web_sys::{window, Request, RequestInit, RequestMode, Response};

#[derive(Serialize)]
struct SignalingStartRequest {
    sdp: String,
    parent_client_id: Option<String>,
    ip_version: Option<String>,
    mode: Option<String>,
    /// Connection ID (UUID) for multi-path ECMP testing
    /// Generated by client, echoed back by server
    conn_id: Option<String>,
}

#[derive(Deserialize)]
struct SignalingStartResponse {
    client_id: String,
    parent_client_id: Option<String>,
    ip_version: Option<String>,
    sdp: String,
    /// Connection ID (UUID) for multi-path ECMP testing
    #[serde(default)]
    conn_id: String,
}

#[derive(Serialize)]
struct IceCandidateRequest {
    client_id: String,
    candidate: String,
}

pub async fn send_offer(
    offer_sdp: String,
    parent_client_id: Option<String>,
    ip_version: Option<String>,
) -> Result<(String, Option<String>, Option<String>, String, String), JsValue> {
    send_offer_with_mode(offer_sdp, parent_client_id, ip_version, None, None).await
}

pub async fn send_offer_with_mode(
    offer_sdp: String,
    parent_client_id: Option<String>,
    ip_version: Option<String>,
    mode: Option<String>,
    conn_id: Option<String>,
) -> Result<(String, Option<String>, Option<String>, String, String), JsValue> {
    let window = window().ok_or("No window")?;

    let req_body = SignalingStartRequest {
        sdp: offer_sdp,
        parent_client_id,
        ip_version,
        mode,
        conn_id,
    };
    let body_str =
        serde_json::to_string(&req_body).map_err(|e| JsValue::from_str(&e.to_string()))?;

    let opts = RequestInit::new();
    opts.set_method("POST");
    opts.set_mode(RequestMode::Cors);
    opts.set_body(&JsValue::from_str(&body_str));

    log::debug!("JSON body: {}", &body_str);

    let url = format!(
        "{}/api/signaling/start",
        window
            .location()
            .origin()
            .map_err(|_| JsValue::from_str("No origin"))?
    );

    let request = Request::new_with_str_and_init(&url, &opts)?;
    request.headers().set("Content-Type", "application/json")?;

    let resp_value = JsFuture::from(window.fetch_with_request(&request)).await?;
    let resp: Response = resp_value.dyn_into()?;

    let json = JsFuture::from(resp.json()?).await?;
    let response: SignalingStartResponse = serde_wasm_bindgen::from_value(json)?;

    Ok((
        response.client_id,
        response.parent_client_id,
        response.ip_version,
        response.sdp,
        response.conn_id,
    ))
}

pub async fn send_ice_candidate(client_id: &str, candidate: &str) -> Result<(), JsValue> {
    let window = window().ok_or("No window")?;

    let req_body = IceCandidateRequest {
        client_id: client_id.to_string(),
        candidate: candidate.to_string(),
    };
    let body_str =
        serde_json::to_string(&req_body).map_err(|e| JsValue::from_str(&e.to_string()))?;

    let opts = RequestInit::new();
    opts.set_method("POST");
    opts.set_mode(RequestMode::Cors);
    opts.set_body(&JsValue::from_str(&body_str));

    let url = format!(
        "{}/api/signaling/ice",
        window
            .location()
            .origin()
            .map_err(|_| JsValue::from_str("No origin"))?
    );

    let request = Request::new_with_str_and_init(&url, &opts)?;
    request.headers().set("Content-Type", "application/json")?;

    let resp_value = JsFuture::from(window.fetch_with_request(&request)).await?;
    let resp: Response = resp_value.dyn_into()?;

    if !resp.ok() {
        return Err(JsValue::from_str("Failed to send ICE candidate"));
    }

    Ok(())
}

pub async fn get_ice_candidates(client_id: &str) -> Result<Vec<String>, JsValue> {
    let window = window().ok_or("No window")?;

    let req_body = IceCandidateRequest {
        client_id: client_id.to_string(),
        candidate: "".to_string(),
    };
    let body_str =
        serde_json::to_string(&req_body).map_err(|e| JsValue::from_str(&e.to_string()))?;

    let opts = RequestInit::new();
    opts.set_method("POST");
    opts.set_mode(RequestMode::Cors);
    opts.set_body(&JsValue::from_str(&body_str));

    let url = format!(
        "{}/api/signaling/ice/remote",
        window
            .location()
            .origin()
            .map_err(|_| JsValue::from_str("No origin"))?
    );

    let request = Request::new_with_str_and_init(&url, &opts)?;
    request.headers().set("Content-Type", "application/json")?;

    let resp_value = JsFuture::from(window.fetch_with_request(&request)).await?;
    let resp: Response = resp_value.dyn_into()?;

    if !resp.ok() {
        return Err(JsValue::from_str("Failed to get ICE candidates"));
    }

    let json = JsFuture::from(resp.json()?).await?;
    let candidates: Vec<String> = serde_wasm_bindgen::from_value(json)?;

    Ok(candidates)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signaling_request_serialization() {
        let req = SignalingStartRequest {
            sdp: "test-sdp".to_string(),
            parent_client_id: None,
            ip_version: Some("ipv4".to_string()),
            mode: None,
            conn_id: Some("test-conn-id".to_string()),
        };
        let json = serde_json::to_string(&req).unwrap();
        assert!(json.contains("test-sdp"));
        assert!(json.contains("ipv4"));
    }
}
