<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Network Measurement Client</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #status { font-weight: bold; margin: 20px 0; }
        #metrics { margin-top: 20px; }
        .dual-stack-container { display: flex; gap: 20px; }
        .stack-column { flex: 1; }
        table { border-collapse: collapse; margin-top: 10px; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #4CAF50; color: white; }
        td:first-child { text-align: left; }
        .ipv4 th { background-color: #2196F3; }
        .ipv6 th { background-color: #FF9800; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        button:hover { background-color: #ddd; }
        .running { color: green; }
        .error { color: red; }
        #chart-container { margin-top: 40px; }
        #metrics-chart { max-height: 600px; }
        .chart-controls { margin: 20px 0; }
        .chart-controls button { margin-right: 10px; }
        #wake-lock-status { 
            display: inline-block;
            margin-left: 15px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            background-color: #f0f0f0;
            color: #666;
        }
        #wake-lock-status.active { 
            background-color: #4CAF50;
            color: white;
        }
        #wake-lock-status.unsupported { 
            background-color: #ff9800;
            color: white;
        }
    </style>
</head>
<body>
    <h1>Network Measurement Client</h1>
    <button id="start-btn" onclick="startMeasurement()">Start Measurement</button>
    <button id="analyze-btn" onclick="analyzePath()">Analyze Path</button>
    <span id="wake-lock-status">Wake Lock: Checking...</span>
    <div id="status">Loading WASM module...</div>
    <div id="ayxx"></div>
    <div id="error" style="color: red; font-weight: bold; margin: 10px 0;"></div>
    <div id="metrics">
        <h2>Dual-Stack Network Measurement</h2>
        <div class="dual-stack-container">
            <div class="stack-column">
                <h3>IPv4 Connection</h3>
                <table class="ipv4">
                    <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                    <tr><td>Throughput</td><td id="ipv4-s2c-tp-1">-</td><td id="ipv4-s2c-tp-10">-</td><td id="ipv4-s2c-tp-60">-</td></tr>
                    <tr><td>Delay (ms)</td><td id="ipv4-s2c-delay-1">-</td><td id="ipv4-s2c-delay-10">-</td><td id="ipv4-s2c-delay-60">-</td></tr>
                    <tr><td>Jitter (ms)</td><td id="ipv4-s2c-jitter-1">-</td><td id="ipv4-s2c-jitter-10">-</td><td id="ipv4-s2c-jitter-60">-</td></tr>
                    <tr><td>Loss Rate</td><td id="ipv4-s2c-loss-1">-</td><td id="ipv4-s2c-loss-10">-</td><td id="ipv4-s2c-loss-60">-</td></tr>
                    <tr><td>Reordering</td><td id="ipv4-s2c-reorder-1">-</td><td id="ipv4-s2c-reorder-10">-</td><td id="ipv4-s2c-reorder-60">-</td></tr>
                </table>
            </div>
            <div class="stack-column">
                <h3>IPv6 Connection</h3>
                <table class="ipv6">
                    <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                    <tr><td>Throughput</td><td id="ipv6-s2c-tp-1">-</td><td id="ipv6-s2c-tp-10">-</td><td id="ipv6-s2c-tp-60">-</td></tr>
                    <tr><td>Delay (ms)</td><td id="ipv6-s2c-delay-1">-</td><td id="ipv6-s2c-delay-10">-</td><td id="ipv6-s2c-delay-60">-</td></tr>
                    <tr><td>Jitter (ms)</td><td id="ipv6-s2c-jitter-1">-</td><td id="ipv6-s2c-jitter-10">-</td><td id="ipv6-s2c-jitter-60">-</td></tr>
                    <tr><td>Loss Rate</td><td id="ipv6-s2c-loss-1">-</td><td id="ipv6-s2c-loss-10">-</td><td id="ipv6-s2c-loss-60">-</td></tr>
                    <tr><td>Reordering</td><td id="ipv6-s2c-reorder-1">-</td><td id="ipv6-s2c-reorder-10">-</td><td id="ipv6-s2c-reorder-60">-</td></tr>
                </table>
            </div>
        </div>

        <h2>Client â†’ Server Metrics</h2>
        <p><em>C2S metrics are measured by the server and visible on the <a href="/static/dashboard.html">dashboard</a>.</em></p>
    </div>

    <div id="server-messages-container" style="margin-top: 20px;">
        <h2>Server Messages (Traceroute)</h2>
        <textarea id="server-messages" readonly style="width: 100%; height: 150px; font-family: monospace; font-size: 12px; padding: 10px; border: 1px solid #ddd; background-color: #f5f5f5;"></textarea>
    </div>

    <div id="chart-container">
        <h2>Live Metrics Graph</h2>
        <div class="chart-controls">
            <button onclick="toggleMetric('throughput')">Toggle Throughput</button>
            <button onclick="toggleMetric('delay')">Toggle Delay</button>
            <button onclick="toggleMetric('jitter')">Toggle Jitter</button>
            <button onclick="toggleMetric('loss')">Toggle Loss</button>
            <button onclick="toggleMetric('reordering')">Toggle Reordering</button>
            <button onclick="resetZoom()">Reset Zoom</button>
        </div>
        <canvas id="metrics-chart"></canvas>
    </div>

    <script src="/static/lib/chart.umd.js"></script>
    <script src="/static/lib/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="/static/lib/chartjs-plugin-zoom.min.js"></script>
    <script>
        // Global variables for chart management
        let metricsChart = null;
        let chartData = {
            timestamps: [], // Used for data management and calculating relative time
            ipv4: {
                throughput_1s: [], throughput_10s: [], throughput_60s: [],
                delay_1s: [], delay_10s: [], delay_60s: [],
                jitter_1s: [], jitter_10s: [], jitter_60s: [],
                loss_1s: [], loss_10s: [], loss_60s: [],
                reorder_1s: [], reorder_10s: [], reorder_60s: []
            },
            ipv6: {
                throughput_1s: [], throughput_10s: [], throughput_60s: [],
                delay_1s: [], delay_10s: [], delay_60s: [],
                jitter_1s: [], jitter_10s: [], jitter_60s: [],
                loss_1s: [], loss_10s: [], loss_60s: [],
                reorder_1s: [], reorder_10s: [], reorder_60s: []
            }
        };
        const MAX_DATA_POINTS = 300; // 5 minutes at 1 second intervals
        let lastChartUpdate = 0;
        const CHART_UPDATE_INTERVAL = 1000; // Update chart every 1 second

        // Visible metric groups
        let visibleMetrics = {
            throughput: true,
            delay: true,
            jitter: true,
            loss: true,
            reordering: true
        };

        function initChart() {
            const ctx = document.getElementById('metrics-chart').getContext('2d');
            
            metricsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'time',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            time: {
                                displayFormats: {
                                    millisecond: 'HH:mm:ss.SSS',
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm:ss',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'yyyy-MM-dd HH:mm:ss.SSS'
                            },
                            ticks: {
                                source: 'data',
                                maxRotation: 45,
                                autoSkip: true
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Value'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 20,
                                font: {
                                    size: 10
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    if (context.length > 0) {
                                        const timestamp = context[0].parsed.x;
                                        const date = new Date(timestamp);
                                        return date.toISOString().replace('T', ' ').replace('Z', '');
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    animation: false
                }
            });
            
            updateChartDatasets();
        }

        function updateChartDatasets() {
            const datasets = [];
            const colors = {
                ipv4: { r: 33, g: 150, b: 243 },    // Blue
                ipv6: { r: 255, g: 152, b: 0 }       // Orange
            };

            const metricConfigs = [
                { key: 'throughput', name: 'Throughput', unit: 'KB/s', visible: visibleMetrics.throughput },
                { key: 'delay', name: 'Delay', unit: 'ms', visible: visibleMetrics.delay },
                { key: 'jitter', name: 'Jitter', unit: 'ms', visible: visibleMetrics.jitter },
                { key: 'loss', name: 'Loss', unit: '%', visible: visibleMetrics.loss },
                { key: 'reorder', name: 'Reorder', unit: '%', visible: visibleMetrics.reordering }
            ];

            const windows = [
                { key: '1s', dash: [], width: 2 }
            ];

            for (const metric of metricConfigs) {
                if (!metric.visible) continue;

                for (const window of windows) {
                    for (const [ipVersion, color] of Object.entries(colors)) {
                        const dataKey = `${metric.key}_${window.key}`;
                        const data = chartData[ipVersion][dataKey] || [];
                        
                        datasets.push({
                            label: `${ipVersion.toUpperCase()} ${metric.name} ${window.key} (${metric.unit})`,
                            data: data,
                            borderColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`,
                            backgroundColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`,
                            borderWidth: window.width,
                            borderDash: window.dash,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHitRadius: 5,
                            spanGaps: false
                        });
                    }
                }
            }

            if (metricsChart) {
                metricsChart.data.datasets = datasets;
                metricsChart.update('none');
            }
        }

        function toggleMetric(metricType) {
            visibleMetrics[metricType] = !visibleMetrics[metricType];
            updateChartDatasets();
        }

        function resetZoom() {
            if (metricsChart) {
                metricsChart.resetZoom();
            }
        }

        function addMetricsData(ipv4Metrics, ipv6Metrics) {
            const now = Date.now();
            
            // Only update chart every second to avoid performance issues
            if (now - lastChartUpdate < CHART_UPDATE_INTERVAL) {
                return;
            }
            lastChartUpdate = now;

            // Use milliseconds timestamp for Chart.js time scale
            chartData.timestamps.push(now);

            // Helper to convert bytes/sec to KB/sec
            const bytesToKB = (bytes) => bytes / 1024;

            // Add IPv4 metrics
            chartData.ipv4.throughput_1s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[0]) });
            chartData.ipv4.throughput_10s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[1]) });
            chartData.ipv4.throughput_60s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[2]) });
            chartData.ipv4.delay_1s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[0] });
            chartData.ipv4.delay_10s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[1] });
            chartData.ipv4.delay_60s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[2] });
            chartData.ipv4.jitter_1s.push({ x: now, y: ipv4Metrics.s2c_jitter[0] });
            chartData.ipv4.jitter_10s.push({ x: now, y: ipv4Metrics.s2c_jitter[1] });
            chartData.ipv4.jitter_60s.push({ x: now, y: ipv4Metrics.s2c_jitter[2] });
            chartData.ipv4.loss_1s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[0] });
            chartData.ipv4.loss_10s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[1] });
            chartData.ipv4.loss_60s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[2] });
            chartData.ipv4.reorder_1s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[0] });
            chartData.ipv4.reorder_10s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[1] });
            chartData.ipv4.reorder_60s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[2] });

            // Add IPv6 metrics
            chartData.ipv6.throughput_1s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[0]) });
            chartData.ipv6.throughput_10s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[1]) });
            chartData.ipv6.throughput_60s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[2]) });
            chartData.ipv6.delay_1s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[0] });
            chartData.ipv6.delay_10s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[1] });
            chartData.ipv6.delay_60s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[2] });
            chartData.ipv6.jitter_1s.push({ x: now, y: ipv6Metrics.s2c_jitter[0] });
            chartData.ipv6.jitter_10s.push({ x: now, y: ipv6Metrics.s2c_jitter[1] });
            chartData.ipv6.jitter_60s.push({ x: now, y: ipv6Metrics.s2c_jitter[2] });
            chartData.ipv6.loss_1s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[0] });
            chartData.ipv6.loss_10s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[1] });
            chartData.ipv6.loss_60s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[2] });
            chartData.ipv6.reorder_1s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[0] });
            chartData.ipv6.reorder_10s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[1] });
            chartData.ipv6.reorder_60s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[2] });

            // Limit data points to prevent memory issues
            if (chartData.timestamps.length > MAX_DATA_POINTS) {
                chartData.timestamps.shift();
                for (const ipVersion of ['ipv4', 'ipv6']) {
                    for (const key in chartData[ipVersion]) {
                        chartData[ipVersion][key].shift();
                    }
                }
            }

            // Update chart directly without transformation
            if (metricsChart) {
                updateChartDatasets();
                metricsChart.update('none');
            }
        }

        // Initialize chart when page loads
        window.addEventListener('load', () => {
            initChart();
        });

        // Make addMetricsData globally available
        window.addMetricsData = addMetricsData;
    </script>
    <script type="module">
        const errorEl = document.getElementById('error');
        const statusEl = document.getElementById('status');
        const btnEl = document.getElementById('start-btn');
        const analyzeBtn = document.getElementById('analyze-btn');
        const wakeLockStatusEl = document.getElementById('wake-lock-status');

        // Check if Wake Lock API is supported
        function checkWakeLockSupport() {
            if ('wakeLock' in navigator) {
                wakeLockStatusEl.textContent = 'ðŸ”“ Wake Lock: Ready';
                wakeLockStatusEl.className = '';
            } else {
                wakeLockStatusEl.textContent = 'âš ï¸ Wake Lock: Not Supported';
                wakeLockStatusEl.className = 'unsupported';
            }
        }

        // Call on page load
        checkWakeLockSupport();

        // Wrap in async IIFE for better Safari compatibility
        (async () => {
            try {
                // Cache-busting timestamp
                const cacheBuster = Date.now();

                // Import the JS wrapper (without cache-busting query param for Safari compatibility)
                const module = await import('/public/pkg/wifi_verify_client.js');
                const { default: init, start_measurement, analyze_path } = module;

                // Initialize WASM with explicit path and cache-busting
                // Pass the .wasm file path to init() for Safari compatibility
                await init(`/public/pkg/wifi_verify_client_bg.wasm?v=${cacheBuster}`);
                console.log('WASM module loaded successfully');
                statusEl.textContent = 'Ready';
                statusEl.className = '';

                window.startMeasurement = async function() {
                    statusEl.textContent = 'Starting...';
                    statusEl.className = '';
                    btnEl.disabled = true;
                    analyzeBtn.disabled = true;
                    errorEl.textContent = '';

                    try {
                        await start_measurement();
                        statusEl.textContent = 'Running - measuring network...';
                        statusEl.className = 'running';
                        
                        // Update wake lock status
                        if ('wakeLock' in navigator) {
                            wakeLockStatusEl.textContent = 'ðŸ”’ Wake Lock: Active';
                            wakeLockStatusEl.className = 'active';
                        }
                    } catch (e) {
                        const errMsg = 'Measurement error: ' + (e.message || e);
                        statusEl.textContent = 'Error';
                        statusEl.className = 'error';
                        errorEl.textContent = errMsg;
                        btnEl.disabled = false;
                        analyzeBtn.disabled = false;
                        console.error('Measurement error:', e);
                    }
                };

                window.analyzePath = async function() {
                    statusEl.textContent = 'Analyzing path...';
                    statusEl.className = '';
                    btnEl.disabled = true;
                    analyzeBtn.disabled = true;
                    errorEl.textContent = '';
                    
                    // Clear the server messages textarea
                    const serverMessagesEl = document.getElementById('server-messages');
                    if (serverMessagesEl) {
                        serverMessagesEl.value = '';
                    }

                    try {
                        await analyze_path();
                        statusEl.textContent = 'Path analysis complete';
                        statusEl.className = '';
                        btnEl.disabled = false;
                        analyzeBtn.disabled = false;
                        
                        // Update wake lock status
                        if ('wakeLock' in navigator) {
                            wakeLockStatusEl.textContent = 'ðŸ”“ Wake Lock: Ready';
                            wakeLockStatusEl.className = '';
                        }
                    } catch (e) {
                        const errMsg = 'Path analysis error: ' + (e.message || e);
                        statusEl.textContent = 'Error';
                        statusEl.className = 'error';
                        errorEl.textContent = errMsg;
                        btnEl.disabled = false;
                        analyzeBtn.disabled = false;
                        console.error('Path analysis error:', e);
                    }
                };
            } catch (e) {
                const errMsg = 'Failed to load WASM module: ' + (e.message || e);
                statusEl.textContent = 'Failed to load';
                statusEl.className = 'error';
                errorEl.textContent = errMsg;
                console.error('WASM load error:', e);
                console.error('Full error:', e.stack);

                window.startMeasurement = function() {
                    alert('WASM module failed to load. Please refresh the page.');
                };
                
                window.analyzePath = function() {
                    alert('WASM module failed to load. Please refresh the page.');
                };
            }
        })();
    </script>
</body>
</html>
