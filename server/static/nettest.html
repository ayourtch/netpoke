<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Network Measurement Client</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #status { font-weight: bold; margin: 20px 0; }
        #metrics { margin-top: 20px; }
        .dual-stack-container { display: flex; gap: 20px; }
        .stack-column { flex: 1; }
        table { border-collapse: collapse; margin-top: 10px; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #4CAF50; color: white; }
        td:first-child { text-align: left; }
        .ipv4 th { background-color: #2196F3; }
        .ipv6 th { background-color: #FF9800; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        button:hover { background-color: #ddd; }
        .running { color: green; }
        .error { color: red; }
        #chart-container { margin-top: 40px; }
        #metrics-chart { max-height: 600px; }
        .chart-controls { margin: 20px 0; }
        .chart-controls button { margin-right: 10px; }
    </style>
</head>
<body>
    <h1>Network Measurement Client</h1>
    <button id="start-btn" onclick="startMeasurement()">Start Measurement</button>
    <div id="status">Loading WASM module...</div>
    <div id="ayxx"></div>
    <div id="error" style="color: red; font-weight: bold; margin: 10px 0;"></div>
    <div id="metrics">
        <h2>Dual-Stack Network Measurement</h2>
        <div class="dual-stack-container">
            <div class="stack-column">
                <h3>IPv4 Connection</h3>
                <table class="ipv4">
                    <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                    <tr><td>Throughput</td><td id="ipv4-s2c-tp-1">-</td><td id="ipv4-s2c-tp-10">-</td><td id="ipv4-s2c-tp-60">-</td></tr>
                    <tr><td>Delay (ms)</td><td id="ipv4-s2c-delay-1">-</td><td id="ipv4-s2c-delay-10">-</td><td id="ipv4-s2c-delay-60">-</td></tr>
                    <tr><td>Jitter (ms)</td><td id="ipv4-s2c-jitter-1">-</td><td id="ipv4-s2c-jitter-10">-</td><td id="ipv4-s2c-jitter-60">-</td></tr>
                    <tr><td>Loss Rate</td><td id="ipv4-s2c-loss-1">-</td><td id="ipv4-s2c-loss-10">-</td><td id="ipv4-s2c-loss-60">-</td></tr>
                    <tr><td>Reordering</td><td id="ipv4-s2c-reorder-1">-</td><td id="ipv4-s2c-reorder-10">-</td><td id="ipv4-s2c-reorder-60">-</td></tr>
                </table>
            </div>
            <div class="stack-column">
                <h3>IPv6 Connection</h3>
                <table class="ipv6">
                    <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                    <tr><td>Throughput</td><td id="ipv6-s2c-tp-1">-</td><td id="ipv6-s2c-tp-10">-</td><td id="ipv6-s2c-tp-60">-</td></tr>
                    <tr><td>Delay (ms)</td><td id="ipv6-s2c-delay-1">-</td><td id="ipv6-s2c-delay-10">-</td><td id="ipv6-s2c-delay-60">-</td></tr>
                    <tr><td>Jitter (ms)</td><td id="ipv6-s2c-jitter-1">-</td><td id="ipv6-s2c-jitter-10">-</td><td id="ipv6-s2c-jitter-60">-</td></tr>
                    <tr><td>Loss Rate</td><td id="ipv6-s2c-loss-1">-</td><td id="ipv6-s2c-loss-10">-</td><td id="ipv6-s2c-loss-60">-</td></tr>
                    <tr><td>Reordering</td><td id="ipv6-s2c-reorder-1">-</td><td id="ipv6-s2c-reorder-10">-</td><td id="ipv6-s2c-reorder-60">-</td></tr>
                </table>
            </div>
        </div>

        <h2>Client â†’ Server Metrics</h2>
        <p><em>C2S metrics are measured by the server and visible on the <a href="/static/dashboard.html">dashboard</a>.</em></p>
    </div>

    <div id="chart-container">
        <h2>Live Metrics Graph</h2>
        <div class="chart-controls">
            <button onclick="toggleMetric('throughput')">Toggle Throughput</button>
            <button onclick="toggleMetric('delay')">Toggle Delay</button>
            <button onclick="toggleMetric('jitter')">Toggle Jitter</button>
            <button onclick="toggleMetric('loss')">Toggle Loss</button>
            <button onclick="toggleMetric('reordering')">Toggle Reordering</button>
            <button onclick="resetZoom()">Reset Zoom</button>
        </div>
        <canvas id="metrics-chart"></canvas>
    </div>

    <script src="/static/lib/chart.umd.js"></script>
    <script src="/static/lib/chartjs-plugin-zoom.min.js"></script>
    <script>
        // Global variables for chart management
        let metricsChart = null;
        let chartData = {
            timestamps: [], // Used for data management and calculating relative time
            ipv4: {
                throughput_1s: [], throughput_10s: [], throughput_60s: [],
                delay_1s: [], delay_10s: [], delay_60s: [],
                jitter_1s: [], jitter_10s: [], jitter_60s: [],
                loss_1s: [], loss_10s: [], loss_60s: [],
                reorder_1s: [], reorder_10s: [], reorder_60s: []
            },
            ipv6: {
                throughput_1s: [], throughput_10s: [], throughput_60s: [],
                delay_1s: [], delay_10s: [], delay_60s: [],
                jitter_1s: [], jitter_10s: [], jitter_60s: [],
                loss_1s: [], loss_10s: [], loss_60s: [],
                reorder_1s: [], reorder_10s: [], reorder_60s: []
            }
        };
        const MAX_DATA_POINTS = 300; // 5 minutes at 1 second intervals
        let lastChartUpdate = 0;
        const CHART_UPDATE_INTERVAL = 1000; // Update chart every 1 second

        // Visible metric groups
        let visibleMetrics = {
            throughput: true,
            delay: true,
            jitter: true,
            loss: true,
            reordering: true
        };

        function initChart() {
            const ctx = document.getElementById('metrics-chart').getContext('2d');
            
            metricsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Time (seconds ago)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return Math.round(value);
                                }
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Value'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 20,
                                font: {
                                    size: 10
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    animation: false
                }
            });
            
            updateChartDatasets();
        }

        function updateChartDatasets() {
            const datasets = [];
            const colors = {
                ipv4: { r: 33, g: 150, b: 243 },    // Blue
                ipv6: { r: 255, g: 152, b: 0 }       // Orange
            };

            const metricConfigs = [
                { key: 'throughput', name: 'Throughput', unit: 'KB/s', visible: visibleMetrics.throughput },
                { key: 'delay', name: 'Delay', unit: 'ms', visible: visibleMetrics.delay },
                { key: 'jitter', name: 'Jitter', unit: 'ms', visible: visibleMetrics.jitter },
                { key: 'loss', name: 'Loss', unit: '%', visible: visibleMetrics.loss },
                { key: 'reorder', name: 'Reorder', unit: '%', visible: visibleMetrics.reordering }
            ];

            const windows = [
                { key: '1s', dash: [], width: 2 },
                { key: '10s', dash: [5, 5], width: 1.5 },
                { key: '60s', dash: [2, 2], width: 1 }
            ];

            for (const metric of metricConfigs) {
                if (!metric.visible) continue;

                for (const window of windows) {
                    for (const [ipVersion, color] of Object.entries(colors)) {
                        const dataKey = `${metric.key}_${window.key}`;
                        const data = chartData[ipVersion][dataKey] || [];
                        
                        datasets.push({
                            label: `${ipVersion.toUpperCase()} ${metric.name} ${window.key} (${metric.unit})`,
                            data: data,
                            borderColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`,
                            backgroundColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`,
                            borderWidth: window.width,
                            borderDash: window.dash,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHitRadius: 5
                        });
                    }
                }
            }

            if (metricsChart) {
                metricsChart.data.datasets = datasets;
                metricsChart.update('none');
            }
        }

        function toggleMetric(metricType) {
            visibleMetrics[metricType] = !visibleMetrics[metricType];
            updateChartDatasets();
        }

        function resetZoom() {
            if (metricsChart) {
                metricsChart.resetZoom();
            }
        }

        function addMetricsData(ipv4Metrics, ipv6Metrics) {
            const now = Date.now();
            
            // Only update chart every second to avoid performance issues
            if (now - lastChartUpdate < CHART_UPDATE_INTERVAL) {
                return;
            }
            lastChartUpdate = now;

            const timestamp = now / 1000; // Convert to seconds
            chartData.timestamps.push(timestamp);

            // Helper to convert bytes/sec to KB/sec
            const bytesToKB = (bytes) => bytes / 1024;

            // Add IPv4 metrics
            chartData.ipv4.throughput_1s.push({ x: timestamp, y: bytesToKB(ipv4Metrics.s2c_throughput[0]) });
            chartData.ipv4.throughput_10s.push({ x: timestamp, y: bytesToKB(ipv4Metrics.s2c_throughput[1]) });
            chartData.ipv4.throughput_60s.push({ x: timestamp, y: bytesToKB(ipv4Metrics.s2c_throughput[2]) });
            chartData.ipv4.delay_1s.push({ x: timestamp, y: ipv4Metrics.s2c_delay_avg[0] });
            chartData.ipv4.delay_10s.push({ x: timestamp, y: ipv4Metrics.s2c_delay_avg[1] });
            chartData.ipv4.delay_60s.push({ x: timestamp, y: ipv4Metrics.s2c_delay_avg[2] });
            chartData.ipv4.jitter_1s.push({ x: timestamp, y: ipv4Metrics.s2c_jitter[0] });
            chartData.ipv4.jitter_10s.push({ x: timestamp, y: ipv4Metrics.s2c_jitter[1] });
            chartData.ipv4.jitter_60s.push({ x: timestamp, y: ipv4Metrics.s2c_jitter[2] });
            chartData.ipv4.loss_1s.push({ x: timestamp, y: ipv4Metrics.s2c_loss_rate[0] });
            chartData.ipv4.loss_10s.push({ x: timestamp, y: ipv4Metrics.s2c_loss_rate[1] });
            chartData.ipv4.loss_60s.push({ x: timestamp, y: ipv4Metrics.s2c_loss_rate[2] });
            chartData.ipv4.reorder_1s.push({ x: timestamp, y: ipv4Metrics.s2c_reorder_rate[0] });
            chartData.ipv4.reorder_10s.push({ x: timestamp, y: ipv4Metrics.s2c_reorder_rate[1] });
            chartData.ipv4.reorder_60s.push({ x: timestamp, y: ipv4Metrics.s2c_reorder_rate[2] });

            // Add IPv6 metrics
            chartData.ipv6.throughput_1s.push({ x: timestamp, y: bytesToKB(ipv6Metrics.s2c_throughput[0]) });
            chartData.ipv6.throughput_10s.push({ x: timestamp, y: bytesToKB(ipv6Metrics.s2c_throughput[1]) });
            chartData.ipv6.throughput_60s.push({ x: timestamp, y: bytesToKB(ipv6Metrics.s2c_throughput[2]) });
            chartData.ipv6.delay_1s.push({ x: timestamp, y: ipv6Metrics.s2c_delay_avg[0] });
            chartData.ipv6.delay_10s.push({ x: timestamp, y: ipv6Metrics.s2c_delay_avg[1] });
            chartData.ipv6.delay_60s.push({ x: timestamp, y: ipv6Metrics.s2c_delay_avg[2] });
            chartData.ipv6.jitter_1s.push({ x: timestamp, y: ipv6Metrics.s2c_jitter[0] });
            chartData.ipv6.jitter_10s.push({ x: timestamp, y: ipv6Metrics.s2c_jitter[1] });
            chartData.ipv6.jitter_60s.push({ x: timestamp, y: ipv6Metrics.s2c_jitter[2] });
            chartData.ipv6.loss_1s.push({ x: timestamp, y: ipv6Metrics.s2c_loss_rate[0] });
            chartData.ipv6.loss_10s.push({ x: timestamp, y: ipv6Metrics.s2c_loss_rate[1] });
            chartData.ipv6.loss_60s.push({ x: timestamp, y: ipv6Metrics.s2c_loss_rate[2] });
            chartData.ipv6.reorder_1s.push({ x: timestamp, y: ipv6Metrics.s2c_reorder_rate[0] });
            chartData.ipv6.reorder_10s.push({ x: timestamp, y: ipv6Metrics.s2c_reorder_rate[1] });
            chartData.ipv6.reorder_60s.push({ x: timestamp, y: ipv6Metrics.s2c_reorder_rate[2] });

            // Limit data points to prevent memory issues
            if (chartData.timestamps.length > MAX_DATA_POINTS) {
                chartData.timestamps.shift();
                for (const ipVersion of ['ipv4', 'ipv6']) {
                    for (const key in chartData[ipVersion]) {
                        chartData[ipVersion][key].shift();
                    }
                }
            }

            // Update chart with relative time (most recent on right)
            // We recalculate from the original absolute timestamps stored in chartData
            // to avoid the flip-flop bug where transformed values get re-transformed
            if (metricsChart) {
                const latestTime = chartData.timestamps[chartData.timestamps.length - 1];
                
                // Update datasets by recalculating relative time from original chartData
                let datasetIndex = 0;
                const metricConfigs = [
                    { key: 'throughput', visible: visibleMetrics.throughput },
                    { key: 'delay', visible: visibleMetrics.delay },
                    { key: 'jitter', visible: visibleMetrics.jitter },
                    { key: 'loss', visible: visibleMetrics.loss },
                    { key: 'reorder', visible: visibleMetrics.reordering }
                ];
                
                for (const metric of metricConfigs) {
                    if (!metric.visible) continue;
                    
                    const windows = ['1s', '10s', '60s'];
                    for (const window of windows) {
                        for (const ipVersion of ['ipv4', 'ipv6']) {
                            const dataKey = `${metric.key}_${window}`;
                            const originalData = chartData[ipVersion][dataKey];
                            
                            if (datasetIndex < metricsChart.data.datasets.length) {
                                // Transform from absolute timestamps to relative time
                                metricsChart.data.datasets[datasetIndex].data = originalData.map(point => ({
                                    x: latestTime - point.x,
                                    y: point.y
                                }));
                            }
                            datasetIndex++;
                        }
                    }
                }
                
                metricsChart.update('none');
            }
        }

        // Initialize chart when page loads
        window.addEventListener('load', () => {
            initChart();
        });

        // Make addMetricsData globally available
        window.addMetricsData = addMetricsData;
    </script>
    <script type="module">
        const errorEl = document.getElementById('error');
        const statusEl = document.getElementById('status');
        const btnEl = document.getElementById('start-btn');

        // Wrap in async IIFE for better Safari compatibility
        (async () => {
            try {
                // Cache-busting timestamp
                const cacheBuster = Date.now();

                // Import the JS wrapper (without cache-busting query param for Safari compatibility)
                const module = await import('/public/pkg/wifi_verify_client.js');
                const { default: init, start_measurement } = module;

                // Initialize WASM with explicit path and cache-busting
                // Pass the .wasm file path to init() for Safari compatibility
                await init(`/public/pkg/wifi_verify_client_bg.wasm?v=${cacheBuster}`);
                console.log('WASM module loaded successfully');
                statusEl.textContent = 'Ready';
                statusEl.className = '';

                window.startMeasurement = async function() {
                    statusEl.textContent = 'Starting...';
                    statusEl.className = '';
                    btnEl.disabled = true;
                    errorEl.textContent = '';

                    try {
                        await start_measurement();
                        statusEl.textContent = 'Running - measuring network...';
                        statusEl.className = 'running';
                    } catch (e) {
                        const errMsg = 'Measurement error: ' + (e.message || e);
                        statusEl.textContent = 'Error';
                        statusEl.className = 'error';
                        errorEl.textContent = errMsg;
                        btnEl.disabled = false;
                        console.error('Measurement error:', e);
                    }
                };
            } catch (e) {
                const errMsg = 'Failed to load WASM module: ' + (e.message || e);
                statusEl.textContent = 'Failed to load';
                statusEl.className = 'error';
                errorEl.textContent = errMsg;
                console.error('WASM load error:', e);
                console.error('Full error:', e.stack);

                window.startMeasurement = function() {
                    alert('WASM module failed to load. Please refresh the page.');
                };
            }
        })();
    </script>
</body>
</html>
