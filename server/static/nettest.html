<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Measurement</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: Arial, sans-serif; 
            background-color: #f5f5f5;
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        /* Header with logo */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
            padding: 16px 24px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .logo-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #2196F3 0%, #FF9800 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .logo-icon svg {
            width: 24px;
            height: 24px;
            fill: white;
        }
        
        .logo h1 {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        
        .header-badges {
            display: flex;
            gap: 8px;
        }
        
        .badge {
            font-size: 11px;
            padding: 4px 10px;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .badge-ipv4 {
            background-color: rgba(33, 150, 243, 0.1);
            color: #2196F3;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }
        
        .badge-ipv6 {
            background-color: rgba(255, 152, 0, 0.1);
            color: #FF9800;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }
        
        /* Collapsible info section */
        .info-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 24px;
            overflow: hidden;
        }
        
        .info-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            background: linear-gradient(135deg, rgba(33, 150, 243, 0.05) 0%, rgba(255, 152, 0, 0.05) 100%);
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease;
        }
        
        .info-header:hover {
            background: linear-gradient(135deg, rgba(33, 150, 243, 0.1) 0%, rgba(255, 152, 0, 0.1) 100%);
        }
        
        .info-header h2 {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .info-header h2 svg {
            width: 20px;
            height: 20px;
            fill: #2196F3;
        }
        
        .info-toggle {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            background: rgba(33, 150, 243, 0.1);
            transition: transform 0.3s ease, background-color 0.2s ease;
        }
        
        .info-toggle svg {
            width: 16px;
            height: 16px;
            fill: #2196F3;
        }
        
        .info-section.collapsed .info-toggle {
            transform: rotate(-90deg);
        }
        
        .info-content {
            padding: 20px 24px;
            color: #666;
            font-size: 14px;
            line-height: 1.7;
            border-top: 1px solid #eee;
            transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.2s ease;
            max-height: 500px;
            opacity: 1;
            overflow: hidden;
        }
        
        .info-section.collapsed .info-content {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
            border-top: none;
        }
        
        .info-content p {
            margin-bottom: 12px;
        }
        
        .info-content p:last-child {
            margin-bottom: 0;
        }
        
        .info-content strong {
            color: #333;
        }
        
        /* Card sections */
        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 24px;
            margin-bottom: 24px;
        }
        
        .card h2 {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }
        
        .card-description {
            font-size: 12px;
            color: #666;
            margin-bottom: 16px;
            font-style: italic;
        }
        
        /* Controls section */
        .controls-section {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-group label {
            font-weight: 600;
            font-size: 14px;
            color: #333;
        }
        
        select {
            padding: 10px 14px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        
        select:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }
        
        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
        }
        
        .btn:hover:not(:disabled) {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }
        
        .btn:active:not(:disabled) {
            transform: translateY(0);
        }
        
        .btn-primary {
            background-color: #2196F3;
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background-color: #1976D2;
        }
        
        .btn-danger {
            background-color: #f44336;
            color: white;
        }
        
        .btn-danger:hover:not(:disabled) {
            background-color: #d32f2f;
        }
        
        .btn:disabled {
            background-color: #ccc;
            color: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        #wake-lock-status { 
            display: inline-flex;
            align-items: center;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            background-color: #f0f0f0;
            color: #666;
        }
        
        #wake-lock-status.active { 
            background-color: #4CAF50;
            color: white;
        }
        
        #wake-lock-status.unsupported { 
            background-color: #ff9800;
            color: white;
        }
        
        /* Status bar */
        #status {
            padding: 14px 20px;
            background: white;
            border-radius: 8px;
            margin-bottom: 24px;
            font-weight: 500;
            color: #666;
            border-left: 4px solid #2196F3;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }
        
        #status.running {
            border-left-color: #4CAF50;
            color: #2e7d32;
        }
        
        #status.error {
            border-left-color: #f44336;
            color: #c62828;
        }
        
        #error {
            color: #c62828;
            font-weight: bold;
            padding: 12px 16px;
            background-color: #ffebee;
            border: 1px solid #ef9a9a;
            border-radius: 8px;
            margin-bottom: 16px;
            display: none;
        }
        
        #error:not(:empty) {
            display: block;
        }
        
        /* Dual stack containers */
        .dual-stack-container { 
            display: flex; 
            gap: 20px; 
        }
        
        .stack-column { 
            flex: 1; 
        }
        
        .stack-column h3 {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 12px;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse; 
            margin-top: 10px; 
            width: 100%; 
            border-radius: 8px;
            overflow: hidden;
        }
        
        th, td { 
            border: 1px solid #e0e0e0; 
            padding: 10px 12px; 
            text-align: center; 
            font-size: 13px;
        }
        
        th { 
            background-color: #4CAF50; 
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
        }
        
        td:first-child { 
            text-align: left; 
        }
        
        .ipv4 th { 
            background-color: #2196F3; 
        }
        
        .ipv6 th { 
            background-color: #FF9800; 
        }
        
        tr:nth-child(even) {
            background-color: #fafafa;
        }
        
        tr:hover {
            background-color: #f0f7ff;
        }
        
        /* Peer connections grid */
        #peer-connections-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 16px;
        }
        
        .peer-connection-placeholder {
            text-align: center;
            color: #999;
            padding: 24px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            background: #fafafa;
        }
        
        /* Traceroute visualization */
        .traceroute-box {
            border: 1px solid #e0e0e0;
            background-color: #fafafa;
            padding: 20px;
            min-height: 200px;
            overflow-x: auto;
            border-radius: 10px;
        }
        
        .traceroute-box.ipv4 {
            border-color: rgba(33, 150, 243, 0.3);
        }
        
        .traceroute-box.ipv6 {
            border-color: rgba(255, 152, 0, 0.3);
        }
        
        .traceroute-placeholder {
            text-align: center;
            color: #999;
            padding: 40px;
        }
        
        /* Server messages */
        #server-messages {
            width: 100%;
            height: 150px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            padding: 14px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background-color: #fafafa;
            resize: vertical;
        }
        
        /* Packet capture section */
        .capture-buttons {
            display: flex;
            gap: 16px;
            align-items: flex-start;
            flex-wrap: wrap;
        }
        
        .capture-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .capture-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            text-decoration: none;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        
        .capture-btn:hover:not(:disabled) {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .capture-btn.green {
            background-color: #4CAF50;
            color: white;
        }
        
        .capture-btn.green:hover {
            background-color: #43A047;
        }
        
        .capture-btn.purple {
            background-color: #9C27B0;
            color: white;
        }
        
        .capture-btn.purple:hover:not(:disabled) {
            background-color: #8E24AA;
        }
        
        .capture-btn.deep-purple {
            background-color: #673AB7;
            color: white;
        }
        
        .capture-btn.deep-purple:hover:not(:disabled) {
            background-color: #5E35B1;
        }
        
        .capture-btn.blue {
            background-color: #2196F3;
            color: white;
        }
        
        .capture-btn.blue:hover {
            background-color: #1E88E5;
        }
        
        .capture-btn:disabled {
            background-color: #ccc;
            color: #666;
            cursor: not-allowed;
        }
        
        .capture-status {
            color: #666;
            font-size: 13px;
        }
        
        /* Probe stats */
        .probe-stats-box {
            padding: 16px;
            background: #fafafa;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            min-height: 120px;
        }
        
        .probe-stats-placeholder {
            text-align: center;
            color: #999;
        }
        
        /* Chart container */
        #probe-stats-chart-container { 
            margin-top: 24px; 
        }
        
        .probe-stats-chart-controls {
            margin-bottom: 16px;
        }
        
        #probe-stats-chart { 
            max-height: 300px; 
        }
        
        .chart-controls { 
            margin: 20px 0; 
        }
        
        .chart-controls button { 
            margin-right: 10px; 
        }
        
        /* Footer */
        .footer {
            text-align: center;
            padding: 24px;
            color: #999;
            font-size: 12px;
        }
        
        .footer a {
            color: #2196F3;
            text-decoration: none;
        }
        
        .footer a:hover {
            text-decoration: underline;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 12px;
                text-align: center;
            }
            
            .controls-section {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .dual-stack-container {
                flex-direction: column;
            }
            
            #peer-connections-list {
                grid-template-columns: 1fr;
            }
            
            .capture-buttons {
                flex-direction: column;
            }
        }

        /* Recording Section */
        .recording-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 24px;
            overflow: hidden;
        }

        .recording-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            cursor: pointer;
            user-select: none;
        }

        .recording-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recording-icon {
            font-size: 20px;
        }

        .status-badge {
            font-size: 11px;
            padding: 4px 10px;
            border-radius: 6px;
            font-weight: 500;
            margin-left: 8px;
        }

        .status-badge.ready {
            background-color: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
        }

        .status-badge.recording {
            background-color: rgba(244, 67, 54, 0.1);
            color: #F44336;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .status-badge.saving {
            background-color: rgba(33, 150, 243, 0.1);
            color: #2196F3;
        }

        .recording-toggle {
            background: none;
            border: none;
            font-size: 14px;
            color: #666;
            cursor: pointer;
            padding: 4px 8px;
            transition: transform 0.2s;
        }

        .recording-toggle.open {
            transform: rotate(180deg);
        }

        .recording-content {
            padding: 0 24px 24px 24px;
        }

        .recording-mode-group {
            margin-bottom: 20px;
        }

        .recording-mode-group h3 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
        }

        .recording-mode-group label {
            display: inline-block;
            margin-right: 16px;
            font-size: 14px;
        }

        .control-group {
            margin-bottom: 20px;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 8px;
        }

        .control-group h3 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .position-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .position-selector button {
            padding: 8px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .position-selector button:hover {
            border-color: #2196F3;
        }

        .position-selector button.selected {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }

        .btn-primary {
            width: 100%;
            padding: 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 8px;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .btn-danger {
            width: 100%;
            padding: 12px;
            background: #F44336;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-danger:hover {
            background: #da190b;
        }

        .recordings-list {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #eee;
        }

        .recordings-list h3 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #555;
        }

        #recordings-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .recording-item {
            background: #f9f9f9;
            padding: 12px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .recording-item-info {
            flex: 1;
        }

        .recording-item-actions {
            display: flex;
            gap: 8px;
        }

        .recording-item-actions button {
            padding: 6px 12px;
            font-size: 12px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 6px;
            cursor: pointer;
        }

        .recording-item-actions button:hover {
            background: #f0f0f0;
        }

        .source-label {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            margin-left: 5px;
            color: white;
        }

        .source-camera {
            background: #34C759;
        }

        .source-screen {
            background: #FF9500;
        }

        .source-combined {
            background: #AF52DE;
        }

        /* Upload progress styles */
        .upload-progress {
            margin-top: 8px;
            width: 100%;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2196F3, #4CAF50);
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
            display: block;
        }

        .btn-upload {
            background: #4CAF50 !important;
            color: white !important;
            border-color: #4CAF50 !important;
        }

        .btn-upload:hover {
            background: #45a049 !important;
        }

        .btn-upload.uploading {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-upload.success {
            background: #2e7d32 !important;
        }

        .btn-upload.error {
            background: #f44336 !important;
            border-color: #f44336 !important;
        }

        .recording-notes {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
            font-style: italic;
        }

        .recording-notes:empty::before {
            content: "";
        }

        .btn-notes {
            background: #2196F3 !important;
            color: white !important;
            border-color: #2196F3 !important;
        }

        .btn-notes:hover {
            background: #1976D2 !important;
        }

        .recording-item {
            flex-direction: column;
            align-items: stretch;
        }

        .recording-item .recording-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo">
                <div class="logo-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 3C7.03 3 3 7.03 3 12s4.03 9 9 9 9-4.03 9-9-4.03-9-9-9zm0 16c-3.86 0-7-3.14-7-7s3.14-7 7-7 7 3.14 7 7-3.14 7-7 7z"/>
                        <path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0 8c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3z"/>
                        <circle cx="12" cy="12" r="1.5"/>
                    </svg>
                </div>
                <h1>Network Measurement</h1>
            </div>
            <div class="header-badges">
                <span class="badge badge-ipv4">IPv4</span>
                <span class="badge badge-ipv6">IPv6</span>
            </div>
        </div>
        
        <!-- Collapsible Info Section -->
        <div class="info-section" id="info-section">
            <div class="info-header" onclick="toggleInfoSection()">
                <h2>
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>
                    </svg>
                    About Network Measurement
                </h2>
                <div class="info-toggle">
                    <svg viewBox="0 0 24 24">
                        <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
                    </svg>
                </div>
            </div>
            <div class="info-content">
                <p>
                    This tool performs <strong>end-to-end application-layer network measurements</strong> to understand what your applications actually experience when communicating over the network. Unlike traditional WiFi survey tools that focus on radio frequency (RF) metrics, NetPoke measures real network performance.
                </p>
                <p>
                    <strong>How it works:</strong> The measurement uses WebRTC data channels to establish connections to our measurement server. It then performs traceroute analysis to discover the network path, followed by continuous probe streams to measure latency, jitter, packet loss, and reordering. Multiple connections can be established to detect ECMP (Equal-Cost Multi-Path) routing in your network.
                </p>
                <p>
                    <strong>What is measured:</strong> Round-trip delay (latency), delay variation (jitter), packet loss rate, out-of-order packet delivery, and network path characteristics. Results are shown for both IPv4 and IPv6 when available, giving you a complete dual-stack view of your network performance.
                </p>
            </div>
        </div>

        <!-- Controls Card -->
        <div class="card">
            <div class="controls-section">
                <div class="control-group">
                    <label for="conn-count">Connections per Address Family (ECMP):</label>
                    <select id="conn-count">
                        <option value="1" selected>1 connection</option>
                        <option value="2">2 connections</option>
                        <option value="4">4 connections</option>
                        <option value="8">8 connections</option>
                        <option value="16">16 connections</option>
                    </select>
                </div>
                <div class="control-group">
                    <button id="analyze-network-btn" class="btn btn-primary" onclick="analyzeNetwork()">Analyze Network</button>
                    <button id="stop-testing-btn" class="btn btn-danger" onclick="stopTesting()" disabled>Stop Testing</button>
                </div>
                <span id="wake-lock-status">Wake Lock: Checking...</span>
            </div>
        </div>
        
        <!-- Status -->
        <div id="status">Loading WASM module...</div>
        <div id="ayxx"></div>
        <div id="error"></div>

        <!-- Peer Connections Card -->
        <div class="card" id="peer-connections-container">
            <h2>Peer Connections</h2>
            <p class="card-description">Active peer connections with their connection IDs (matching traceroute data) and address information.</p>
            <div id="peer-connections-list">
                <div class="peer-connection-placeholder">No active connections. Click "Analyze Network" to start.</div>
            </div>
        </div>

        <!-- Traceroute Visualization Card -->
        <div class="card" id="traceroute-visualization">
            <h2>Traceroute Path Visualization</h2>
            <p class="card-description">Visual representation of network path. Each column represents a hop, nodes show router addresses. Hover for details.</p>
            
            <div class="dual-stack-container">
                <div class="stack-column">
                    <h3 style="color: #2196F3;">IPv4 Path</h3>
                    <div id="traceroute-graph-ipv4" class="traceroute-box ipv4">
                        <div class="traceroute-placeholder">No IPv4 traceroute data available.</div>
                    </div>
                </div>
                <div class="stack-column">
                    <h3 style="color: #FF9800;">IPv6 Path</h3>
                    <div id="traceroute-graph-ipv6" class="traceroute-box ipv6">
                        <div class="traceroute-placeholder">No IPv6 traceroute data available.</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Server Messages Card -->
        <div class="card" id="server-messages-container">
            <h2>Server Messages (Traceroute Log)</h2>
            <p class="card-description">Raw traceroute messages. Messages are prefixed with [conn_id] to identify which connection each hop belongs to.</p>
            <textarea id="server-messages" readonly></textarea>
        </div>

        <!-- Packet Capture Card -->
        <div class="card" id="packet-capture-container">
            <h2>Packet Capture & Tracing</h2>
            <p class="card-description">Download captured network traffic (PCAP) or server logs (tracing buffer) for analysis.</p>
            <div class="capture-buttons">
                <div class="capture-item" id="download-pcap-container" style="display: none;">
                    <a id="download-pcap-btn" href="/api/capture/download" class="capture-btn green">
                        üì• Download PCAP
                    </a>
                    <span id="capture-status" class="capture-status">Checking capture status...</span>
                </div>
                <div class="capture-item">
                    <button id="download-survey-pcap-btn" onclick="downloadSurveyPcap()" class="capture-btn purple" disabled>
                        üì• Download Survey PCAP
                    </button>
                    <span id="survey-pcap-status" class="capture-status">Start a survey session first</span>
                </div>
                <div class="capture-item">
                    <button id="download-survey-keylog-btn" onclick="downloadSurveyKeylog()" class="capture-btn deep-purple" disabled>
                        üîê Download Survey DTLS keys
                    </button>
                    <span id="survey-keylog-status" class="capture-status">Start a survey session first</span>
                </div>
                <div class="capture-item" id="download-tracing-container" style="display: none;">
                    <a id="download-tracing-btn" href="/api/tracing/download" class="capture-btn blue">
                        üìã Download Tracing Log
                    </a>
                    <span id="tracing-status" class="capture-status">Checking tracing status...</span>
                </div>
            </div>
        </div>

        <!-- Probe Stats Card -->
        <div class="card" id="probe-stats-container">
            <h2>Probe Stream Statistics (Baseline Measurement)</h2>
            <p class="card-description">Real-time statistics from 100pps probe streams. Delay deviation shows deviation from incrementally calculated baseline. Bands show 50th/99th percentile and full range.</p>
            <div class="dual-stack-container">
                <div class="stack-column">
                    <h3 style="color: #2196F3;">IPv4 Statistics</h3>
                    <div id="probe-stats-ipv4" class="probe-stats-box">
                        <div class="probe-stats-placeholder">Waiting for probe data...</div>
                    </div>
                </div>
                <div class="stack-column">
                    <h3 style="color: #FF9800;">IPv6 Statistics</h3>
                    <div id="probe-stats-ipv6" class="probe-stats-box">
                        <div class="probe-stats-placeholder">Waiting for probe data...</div>
                    </div>
                </div>
            </div>
            <div id="probe-stats-chart-container">
                <div class="probe-stats-chart-controls">
                    <button class="btn btn-primary" onclick="resetZoom()">Reset Zoom</button>
                </div>
                <canvas id="probe-stats-chart" height="300"></canvas>
            </div>
        </div>

        <!-- Recording Section -->
        <div class="recording-section">
            <div class="recording-header" onclick="toggleRecordingPanel()">
                <h2>
                    <span class="recording-icon">üìπ</span>
                    Recording
                    <span id="recording-status" class="status-badge ready">Ready</span>
                </h2>
                <button class="recording-toggle" id="recording-toggle">‚ñº</button>
            </div>
            <div class="recording-content" id="recording-content" style="display:none">

                <!-- Mode Selection -->
                <div class="recording-mode-group">
                    <h3>Recording Mode</h3>
                    <label><input type="radio" name="recordMode" id="mode-camera" value="camera"> Camera Only</label>
                    <label><input type="radio" name="recordMode" id="mode-screen" value="screen"> Screen Only</label>
                    <label><input type="radio" name="recordMode" id="mode-combined" value="combined" checked> Combined (PiP)</label>
                </div>

                <!-- PiP Controls -->
                <div id="pip-controls" class="control-group">
                    <h3>Camera Position</h3>
                    <label>
                        Size: <input type="range" id="pip-size" min="10" max="40" value="25">
                        <span id="pip-size-value">25%</span>
                    </label>
                    <div class="position-selector">
                        <button id="pip-pos-tl" data-position="topleft">TL</button>
                        <button id="pip-pos-tr" data-position="topright">TR</button>
                        <button id="pip-pos-bl" data-position="bottomleft">BL</button>
                        <button id="pip-pos-br" data-position="bottomright" class="selected">BR</button>
                    </div>
                </div>

                <!-- Chart Controls -->
                <div id="chart-controls" class="control-group">
                    <h3>Chart Overlay</h3>
                    <label><input type="checkbox" id="chart-enable" checked> Include Charts</label>
                    <label>
                        Chart:
                        <select id="chart-type">
                            <option value="metrics-chart">Latency</option>
                            <option value="probe-stats-chart" selected>Probe Stats</option>
                            <option value="both">Both Charts</option>
                        </select>
                    </label>
                    <label>
                        Chart Height: <input type="range" id="chart-size" min="10" max="40" value="20">
                        <span id="chart-size-value">20%</span>
                    </label>
                    <div class="position-selector">
                        <button id="chart-pos-top" data-position="top">Top</button>
                        <button id="chart-pos-bottom" data-position="bottom" class="selected">Bottom</button>
                    </div>
                </div>

                <!-- Sensor Toggle -->
                <div class="control-group">
                    <label><input type="checkbox" id="show-sensors-overlay" checked> Show Sensors</label>
                </div>

                <!-- Recording Buttons -->
                <button id="start-recording" class="btn-primary">Start Recording</button>
                <button id="stop-recording" class="btn-danger" style="display:none">Stop Recording</button>

                <!-- Recording Metrics Display -->
                <div id="recording-metrics" style="display:none; margin-top: 12px; padding: 12px; background: #f5f5f5; border-radius: 8px;">
                    <div style="display: flex; gap: 16px; flex-wrap: wrap;">
                        <span><strong>Source:</strong> <span id="sourceType">-</span></span>
                        <span><strong>Duration:</strong> <span id="recording-duration">0.0s</span></span>
                        <span><strong>Frames:</strong> <span id="recording-frames">0</span></span>
                        <span><strong>Size:</strong> <span id="recording-size">0.00 MB</span></span>
                    </div>
                    <!-- Sensor status displays (matching old code) -->
                    <div style="margin-top: 8px; font-family: monospace; font-size: 11px;">
                        <div>GPS: <span id="gps">acquiring...</span></div>
                        <div>Magnetometer: <span id="magnetometer">-</span></div>
                        <div>Orientation: <span id="orientation">-</span></div>
                        <div>Acceleration: <span id="acceleration">-</span></div>
                    </div>
                </div>

                <!-- Saved Recordings List -->
                <div id="recordings-list" class="recordings-list">
                    <h3>Saved Recordings</h3>
                    <div id="recordings-container"></div>
                </div>

                <!-- Hidden canvases for Chart.js rendering (used for overlay in recordings) -->
                <!-- Note: Using position:absolute and left:-9999px instead of display:none -->
                <!-- because display:none prevents the canvas from being rendered/composited -->
                <div style="position:absolute; left:-9999px; width:400px; height:300px;" id="hidden-charts">
                    <canvas id="metrics-chart" width="400" height="300"></canvas>
                    <canvas id="latency-chart" width="400" height="300"></canvas>
                    <canvas id="throughput-chart" width="400" height="300"></canvas>
                </div>

            </div>
        </div>
        
        <!-- Footer -->
        <div class="footer">
            <a href="/static/dashboard.html">Dashboard</a> | 
            <a href="/">Home</a>
        </div>
    </div> <!-- End container -->

    <script src="/static/lib/chart.umd.js"></script>
    <script src="/static/lib/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="/static/lib/chartjs-plugin-zoom.min.js"></script>

    <!-- Recorder JavaScript modules are loaded via WASM bindgen, not as scripts -->

    <script>
        // Collapsible info section with localStorage persistence
        const INFO_COLLAPSED_KEY = 'netpoke_info_collapsed';
        
        function toggleInfoSection() {
            const section = document.getElementById('info-section');
            const isCollapsed = section.classList.toggle('collapsed');
            try {
                localStorage.setItem(INFO_COLLAPSED_KEY, isCollapsed ? 'true' : 'false');
            } catch (e) {
                // localStorage may be unavailable (private browsing, storage quota exceeded)
                console.warn('Could not save info section state to localStorage:', e);
            }
        }

        // Recording panel toggle
        function toggleRecordingPanel() {
            const content = document.getElementById('recording-content');
            const toggle = document.getElementById('recording-toggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.classList.add('open');
            } else {
                content.style.display = 'none';
                toggle.classList.remove('open');
            }
        }
        
        function initInfoSection() {
            const section = document.getElementById('info-section');
            try {
                const savedState = localStorage.getItem(INFO_COLLAPSED_KEY);
                if (savedState === 'true') {
                    section.classList.add('collapsed');
                }
            } catch (e) {
                // localStorage may be unavailable (private browsing, storage quota exceeded)
                console.warn('Could not read info section state from localStorage:', e);
            }
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', initInfoSection);
        
        // Global variables for chart management
        let metricsChart = null;
        let chartData = {
            timestamps: [], // Used for data management and calculating relative time
            ipv4: {
                throughput_1s: [], throughput_10s: [], throughput_60s: [],
                delay_1s: [], delay_10s: [], delay_60s: [],
                jitter_1s: [], jitter_10s: [], jitter_60s: [],
                loss_1s: [], loss_10s: [], loss_60s: [],
                reorder_1s: [], reorder_10s: [], reorder_60s: []
            },
            ipv6: {
                throughput_1s: [], throughput_10s: [], throughput_60s: [],
                delay_1s: [], delay_10s: [], delay_60s: [],
                jitter_1s: [], jitter_10s: [], jitter_60s: [],
                loss_1s: [], loss_10s: [], loss_60s: [],
                reorder_1s: [], reorder_10s: [], reorder_60s: []
            }
        };
        const MAX_DATA_POINTS = 300; // 5 minutes at 1 second intervals
        let lastChartUpdate = 0;
        const CHART_UPDATE_INTERVAL = 1000; // Update chart every 1 second

        // Visible metric groups
        let visibleMetrics = {
            throughput: true,
            delay: true,
            jitter: true,
            loss: true,
            reordering: true
        };

        function initChart() {
            const canvas = document.getElementById('metrics-chart');
            if (!canvas) {
                console.warn('[Chart] metrics-chart canvas not found, skipping chart initialization');
                return;
            }
            const ctx = canvas.getContext('2d');
            
            metricsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: false,  // Fixed size for off-screen rendering (used in recording overlay)
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'time',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            time: {
                                displayFormats: {
                                    millisecond: 'HH:mm:ss.SSS',
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm:ss',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'yyyy-MM-dd HH:mm:ss.SSS'
                            },
                            ticks: {
                                source: 'data',
                                maxRotation: 45,
                                autoSkip: true
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Value'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 20,
                                font: {
                                    size: 10
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
				    modifierKey: 'ctrl'
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    if (context.length > 0) {
                                        const timestamp = context[0].parsed.x;
                                        const date = new Date(timestamp);
                                        return date.toISOString().replace('T', ' ').replace('Z', '');
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    animation: false
                }
            });
            
            updateChartDatasets();
        }

        function updateChartDatasets() {
            const datasets = [];
            const colors = {
                ipv4: { r: 33, g: 150, b: 243 },    // Blue
                ipv6: { r: 255, g: 152, b: 0 }       // Orange
            };

            const metricConfigs = [
                { key: 'throughput', name: 'Throughput', unit: 'KB/s', visible: visibleMetrics.throughput },
                { key: 'delay', name: 'Delay', unit: 'ms', visible: visibleMetrics.delay },
                { key: 'jitter', name: 'Jitter', unit: 'ms', visible: visibleMetrics.jitter },
                { key: 'loss', name: 'Loss', unit: '%', visible: visibleMetrics.loss },
                { key: 'reorder', name: 'Reorder', unit: '%', visible: visibleMetrics.reordering }
            ];

            const windows = [
                { key: '1s', dash: [], width: 2 }
            ];

            for (const metric of metricConfigs) {
                if (!metric.visible) continue;

                for (const window of windows) {
                    for (const [ipVersion, color] of Object.entries(colors)) {
                        const dataKey = `${metric.key}_${window.key}`;
                        const data = chartData[ipVersion][dataKey] || [];
                        
                        datasets.push({
                            label: `${ipVersion.toUpperCase()} ${metric.name} ${window.key} (${metric.unit})`,
                            data: data,
                            borderColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`,
                            backgroundColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`,
                            borderWidth: window.width,
                            borderDash: window.dash,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHitRadius: 5,
                            spanGaps: false
                        });
                    }
                }
            }

            if (metricsChart) {
                metricsChart.data.datasets = datasets;
                metricsChart.update('none');
            }
        }

        function toggleMetric(metricType) {
            visibleMetrics[metricType] = !visibleMetrics[metricType];
            updateChartDatasets();
        }

        function resetZoom() {
            if (metricsChart) {
                metricsChart.resetZoom();
            }
        }

        function addMetricsData(ipv4Metrics, ipv6Metrics) {
            const now = Date.now();
            
            // Only update chart every second to avoid performance issues
            if (now - lastChartUpdate < CHART_UPDATE_INTERVAL) {
                return;
            }
            lastChartUpdate = now;

            // Use milliseconds timestamp for Chart.js time scale
            chartData.timestamps.push(now);

            // Helper to convert bytes/sec to KB/sec
            const bytesToKB = (bytes) => bytes / 1024;

            // Add IPv4 metrics
            chartData.ipv4.throughput_1s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[0]) });
            chartData.ipv4.throughput_10s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[1]) });
            chartData.ipv4.throughput_60s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[2]) });
            chartData.ipv4.delay_1s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[0] });
            chartData.ipv4.delay_10s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[1] });
            chartData.ipv4.delay_60s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[2] });
            chartData.ipv4.jitter_1s.push({ x: now, y: ipv4Metrics.s2c_jitter[0] });
            chartData.ipv4.jitter_10s.push({ x: now, y: ipv4Metrics.s2c_jitter[1] });
            chartData.ipv4.jitter_60s.push({ x: now, y: ipv4Metrics.s2c_jitter[2] });
            chartData.ipv4.loss_1s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[0] });
            chartData.ipv4.loss_10s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[1] });
            chartData.ipv4.loss_60s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[2] });
            chartData.ipv4.reorder_1s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[0] });
            chartData.ipv4.reorder_10s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[1] });
            chartData.ipv4.reorder_60s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[2] });

            // Add IPv6 metrics
            chartData.ipv6.throughput_1s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[0]) });
            chartData.ipv6.throughput_10s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[1]) });
            chartData.ipv6.throughput_60s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[2]) });
            chartData.ipv6.delay_1s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[0] });
            chartData.ipv6.delay_10s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[1] });
            chartData.ipv6.delay_60s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[2] });
            chartData.ipv6.jitter_1s.push({ x: now, y: ipv6Metrics.s2c_jitter[0] });
            chartData.ipv6.jitter_10s.push({ x: now, y: ipv6Metrics.s2c_jitter[1] });
            chartData.ipv6.jitter_60s.push({ x: now, y: ipv6Metrics.s2c_jitter[2] });
            chartData.ipv6.loss_1s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[0] });
            chartData.ipv6.loss_10s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[1] });
            chartData.ipv6.loss_60s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[2] });
            chartData.ipv6.reorder_1s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[0] });
            chartData.ipv6.reorder_10s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[1] });
            chartData.ipv6.reorder_60s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[2] });

            // Limit data points to prevent memory issues
            if (chartData.timestamps.length > MAX_DATA_POINTS) {
                chartData.timestamps.shift();
                for (const ipVersion of ['ipv4', 'ipv6']) {
                    for (const key in chartData[ipVersion]) {
                        chartData[ipVersion][key].shift();
                    }
                }
            }

            // Update chart directly without transformation
            if (metricsChart) {
                updateChartDatasets();
                metricsChart.update('none');
            }
        }

        // Initialize chart when page loads
        window.addEventListener('load', () => {
            initChart();
        });

        // Make addMetricsData globally available
        window.addMetricsData = addMetricsData;
        
        // Traceroute visualization data structure
        let tracerouteData = {
            // Map of IP version -> connection_id -> array of hop objects
            // Each hop object: { hop: number, ip_addresses: Set<string>, rtts: Map<string, number[]>, messages: string[] }
            ipv4: {},
            ipv6: {}
        };
        
        // MTU tracking data structure
        // Map of IP version -> connection_id -> hop_number -> { value, isExplicit }
        // Stores MTU information for each hop on each connection
        // isExplicit: true = from ICMP Fragmentation Needed, false = inferred from successful delivery
        let mtuData = {
            ipv4: {},
            ipv6: {}
        };
        
        // Function to add traceroute hop data
        function addTracerouteHop(hopData) {
            // Filter out "Probing hop" messages (placeholder messages)
            // This is a defensive measure in case old messages are still in flight
            // or if the server code is reverted temporarily
            if (hopData.message && hopData.message.includes("Probing hop")) {
                return; // Ignore placeholder messages
            }
            
            const connId = hopData.conn_id || 'default';
            const ipAddress = hopData.ip_address;
            
            // Track UDP address pairs for cross-checking
            if (hopData.original_src_port && hopData.original_dest_addr) {
                addConnectionUdpPair(connId, hopData.original_src_port, hopData.original_dest_addr);
            }
            
            // Determine IP version - first try to get it from registered peer connections
            let ipVersion = getIpVersionForConnId(connId);
            
            // Fallback: Determine IP version from the router IP address
            if (!ipVersion) {
                ipVersion = 'ipv4';
                if (ipAddress && ipAddress.includes(':')) {
                    ipVersion = 'ipv6';
                }
            }
            
            // Initialize connection if needed
            if (!tracerouteData[ipVersion][connId]) {
                tracerouteData[ipVersion][connId] = [];
            }
            
            // Find or create hop entry
            let hopEntry = tracerouteData[ipVersion][connId].find(h => h.hop === hopData.hop);
            if (!hopEntry) {
                hopEntry = {
                    hop: hopData.hop,
                    ip_addresses: new Set(),
                    rtts: new Map(),  // Map of IP -> array of RTT values
                    messages: []
                };
                tracerouteData[ipVersion][connId].push(hopEntry);
            }
            
            // Add IP address if present
            if (ipAddress) {
                hopEntry.ip_addresses.add(ipAddress);
                
                // Track RTT for this IP
                if (!hopEntry.rtts.has(ipAddress)) {
                    hopEntry.rtts.set(ipAddress, []);
                }
                hopEntry.rtts.get(ipAddress).push(hopData.rtt_ms);
            }
            
            // Add message if not already present
            if (hopData.message && !hopEntry.messages.includes(hopData.message)) {
                hopEntry.messages.push(hopData.message);
            }
            
            // Re-render the visualization
            renderTracerouteGraph();
        }
        
        // Function to add MTU hop data
        function addMtuHop(mtuHopData) {
            const connId = mtuHopData.conn_id || 'default';
            const hopNum = mtuHopData.hop;
            const mtuValue = mtuHopData.mtu;
            const ipAddress = mtuHopData.ip_address;
            const packetSize = mtuHopData.packet_size;
            
            // Debug logging for MTU message processing
            console.log('[MTU Debug] Processing MTU hop message:', {
                conn_id: connId,
                hop: hopNum,
                ip_address: ipAddress,
                mtu: mtuValue,
                packet_size: packetSize,
                rtt_ms: mtuHopData.rtt_ms,
                full_data: mtuHopData
            });
            
            // Determine IP version - first try to get it from registered peer connections
            let ipVersion = getIpVersionForConnId(connId);
            
            // Fallback: Determine IP version from the router IP address
            if (!ipVersion) {
                ipVersion = 'ipv4';
                if (ipAddress && ipAddress.includes(':')) {
                    ipVersion = 'ipv6';
                }
            }
            
            console.log('[MTU Debug] Determined IP version:', ipVersion, 'for conn_id:', connId);
            
            // MTU Message Processing Logic:
            // 
            // Case 1: Explicit MTU from ICMP Type 3 Code 4 "Fragmentation Needed"
            //   - When we receive a message with an explicit MTU value, it indicates the maximum
            //     packet size that can traverse to hop N
            //   - We store this for hop N-1 (the link between N-1 and N has this limit)
            //
            // Case 2: Implicit MTU from successful packet delivery (TTL Expired)
            //   - When we receive a TTL Expired (ICMP Type 11) without explicit MTU but with packet_size,
            //     it means the packet successfully reached hop N
            //   - This tells us the path to hop N can handle at least packet_size bytes
            //   - We track this as a "minimum working MTU" for that hop
            //   - This is more reliable than waiting for Fragmentation Needed messages, which may be blocked
            //
            // For example: If hop 3 reports MTU 1400, we store it for hop 2.
            // If hop 3 successfully receives a 1500-byte packet, we know hop 2 can handle >= 1500 bytes.
            
            let shouldStore = false;
            let valueToStore = null;
            let targetHop = null;
            let isExplicit = false;
            let storageReason = '';
            
            if (mtuValue != null && mtuValue > 0 && hopNum > 0) {
                // Case 1: Explicit MTU from Fragmentation Needed
                shouldStore = true;
                valueToStore = mtuValue;
                targetHop = hopNum - 1;
                isExplicit = true;
                storageReason = 'explicit MTU from ICMP Fragmentation Needed';
                console.log('[MTU Debug] Explicit MTU value', mtuValue, 'from hop', hopNum);
            } else if (packetSize != null && packetSize > 0 && hopNum > 0) {
                // Case 2: Implicit MTU from successful delivery (TTL Expired)
                // The packet successfully reached hop N, so path to hop N-1 can handle packet_size
                shouldStore = true;
                valueToStore = packetSize;
                targetHop = hopNum - 1;
                isExplicit = false;
                storageReason = 'inferred from successful packet delivery (TTL expired)';
                console.log('[MTU Debug] Packet of size', packetSize, 'successfully reached hop', hopNum, '- inferring minimum MTU');
            }
            
            if (shouldStore && targetHop !== null && valueToStore > 0) {
                console.log('[MTU Debug] Storing MTU value', valueToStore, 'for hop', targetHop, '(', storageReason, ')');
                
                // Initialize connection MTU tracking if needed
                if (!mtuData[ipVersion][connId]) {
                    mtuData[ipVersion][connId] = {};
                }
                
                // Get or initialize MTU for this specific hop
                const currentData = mtuData[ipVersion][connId][targetHop];
                
                if (currentData === undefined) {
                    // No previous data - store new value
                    mtuData[ipVersion][connId][targetHop] = {
                        value: valueToStore,
                        isExplicit: isExplicit
                    };
                    console.log('[MTU Debug] Stored new MTU', valueToStore, '(explicit:', isExplicit, ') for hop', targetHop, 'on', ipVersion, 'connection', connId);
                } else {
                    // Update existing value based on source type
                    const oldValue = currentData.value;
                    const oldIsExplicit = currentData.isExplicit;
                    
                    let newValue = oldValue;
                    let newIsExplicit = oldIsExplicit;
                    
                    if (isExplicit && oldIsExplicit) {
                        // Both explicit: use minimum (most restrictive)
                        newValue = Math.min(oldValue, valueToStore);
                        newIsExplicit = true;
                        console.log('[MTU Debug] Both explicit - using minimum:', newValue);
                    } else if (isExplicit && !oldIsExplicit) {
                        // New is explicit, old is implicit: prefer explicit
                        newValue = valueToStore;
                        newIsExplicit = true;
                        console.log('[MTU Debug] Replacing implicit', oldValue, 'with explicit', newValue);
                    } else if (!isExplicit && oldIsExplicit) {
                        // Old is explicit, new is implicit: keep explicit
                        newValue = oldValue;
                        newIsExplicit = true;
                        console.log('[MTU Debug] Keeping explicit', oldValue, 'over implicit', valueToStore);
                    } else {
                        // Both implicit: use maximum (largest proven working)
                        newValue = Math.max(oldValue, valueToStore);
                        newIsExplicit = false;
                        console.log('[MTU Debug] Both implicit - using maximum:', newValue);
                    }
                    
                    mtuData[ipVersion][connId][targetHop] = {
                        value: newValue,
                        isExplicit: newIsExplicit
                    };
                    console.log('[MTU Debug] Updated MTU from', oldValue, '(explicit:', oldIsExplicit, ') to', newValue, '(explicit:', newIsExplicit, ') for hop', targetHop);
                }
                
                // console.log('[MTU Debug] Current mtuData state:', JSON.stringify(mtuData, null, 2));
                
                // Re-render the visualization to show updated MTU data
                renderTracerouteGraph();
                console.log('[MTU Debug] Triggered re-render of traceroute graph');
            } else {
                console.log('[MTU Debug] Not storing MTU - mtuValue:', mtuValue, 'packetSize:', packetSize, 'hopNum:', hopNum);
            }
        }
        
        // Function to clear traceroute data
        function clearTracerouteData() {
            tracerouteData.ipv4 = {};
            tracerouteData.ipv6 = {};
            mtuData.ipv4 = {};
            mtuData.ipv6 = {};
            renderTracerouteGraph();
        }
        
        // Function to render the traceroute graph
        function renderTracerouteGraph() {
            renderTracerouteGraphForVersion('ipv4');
            renderTracerouteGraphForVersion('ipv6');
        }
        
        function renderTracerouteGraphForVersion(ipVersion) {
            const graphContainer = document.getElementById(`traceroute-graph-${ipVersion}`);
            if (!graphContainer) return;
            
            console.log('[MTU Debug] Rendering traceroute for', ipVersion, '- mtuData:', mtuData[ipVersion]);
            
            const connections = tracerouteData[ipVersion];
            const connIds = Object.keys(connections);
            
            if (connIds.length === 0) {
                const versionLabel = ipVersion.toUpperCase();
                graphContainer.innerHTML = `<div style="text-align: center; color: #999; padding: 40px;">No ${versionLabel} traceroute data available.</div>`;
                return;
            }
            
            // Find max hop number across all connections
            let maxHop = 0;
            connIds.forEach(connId => {
                connections[connId].forEach(hop => {
                    if (hop.hop > maxHop) maxHop = hop.hop;
                });
            });
            
            // Build HTML for the graph
            let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
            
            // For each hop number, create a row
            for (let hopNum = 1; hopNum <= maxHop; hopNum++) {
                html += '<div style="display: flex; align-items: center; gap: 10px; padding: 5px 0;">';
                html += `<div style="min-width: 60px; font-weight: bold; color: #555;">Hop ${hopNum}:</div>`;
                html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; flex: 1;">';
                
                // Collect all hop entries at this hop across all connections
                const hopsAtThisLevel = [];
                connIds.forEach(connId => {
                    const hop = connections[connId].find(h => h.hop === hopNum);
                    if (hop) {
                        hopsAtThisLevel.push({ connId, hop });
                    }
                });
                
                // Collect MTU values for this hop from ALL connections (not per-IP)
                // MTU is a path property, not IP-specific, so we collect it at the hop level
                const hopMtuValues = [];
                connIds.forEach(connId => {
                    if (mtuData[ipVersion][connId] && mtuData[ipVersion][connId][hopNum]) {
                        const mtuInfo = mtuData[ipVersion][connId][hopNum];
                        hopMtuValues.push({
                            connId: connId,
                            mtu: typeof mtuInfo === 'object' ? mtuInfo.value : mtuInfo,  // Handle both old (number) and new (object) formats
                            isExplicit: mtuInfo.isExplicit !== undefined ? mtuInfo.isExplicit : true  // Default to explicit for backward compat
                        });
                    }
                });
                
                if (hopMtuValues.length > 0) {
                    // console.log('[MTU Debug] Found MTU values for hop', hopNum, 'in', ipVersion, ':', hopMtuValues);
                }
                
                if (hopsAtThisLevel.length === 0) {
                    html += '<div style="color: #999; font-style: italic;">No response</div>';
                } else {
                    // Group by unique IP addresses across all connections at this hop
                    const ipToConnections = new Map();
                    hopsAtThisLevel.forEach(({ connId, hop }) => {
                        hop.ip_addresses.forEach(ip => {
                            if (!ipToConnections.has(ip)) {
                                ipToConnections.set(ip, []);
                            }
                            ipToConnections.get(ip).push({ connId, hop });
                        });
                    });
                    
                    // Determine if there are multiple IPs for this hop (highlighting needed)
                    const hasMultipleIps = ipToConnections.size > 1;
                    
                    // Render each unique IP as a node
                    ipToConnections.forEach((connsForIp, ip) => {
                        const connCount = connsForIp.length;
                        
                        // Calculate average RTT for this IP
                        let allRtts = [];
                        connsForIp.forEach(({ hop }) => {
                            if (hop.rtts.has(ip)) {
                                allRtts = allRtts.concat(hop.rtts.get(ip));
                            }
                        });
                        const avgRtt = allRtts.length > 0 ? allRtts.reduce((a, b) => a + b, 0) / allRtts.length : 0;
                        
                        // Filter MTU values to only those from connections that saw this IP
                        const mtuValues = hopMtuValues.filter(mtuEntry => 
                            connsForIp.some(({ connId }) => connId === mtuEntry.connId)
                        );
                        
                        // Calculate MTU range (min-max) for display in box
                        let mtuRangeText = '';
                        if (mtuValues.length > 0) {
                            const mtuNumbers = mtuValues.map(m => m.mtu);
                            const minMtu = Math.min(...mtuNumbers);
                            const maxMtu = Math.max(...mtuNumbers);
                            if (minMtu === maxMtu) {
                                mtuRangeText = `MTU: ${minMtu}`;
                            } else {
                                mtuRangeText = `MTU: ${minMtu}-${maxMtu}`;
                            }
                        }
                        
                        // Create tooltip with literal newlines
                        const tooltipLines = [
                            `Hop ${hopNum}`,
                            `${ip}`,
                            ``,
                            `Connections (${connCount}):`
                        ];
                        connsForIp.forEach(({ connId, hop }) => {
                            const shortId = connId.substring(0, 8);
                            const rtts = hop.rtts.get(ip) || [];
                            const avgConnRtt = rtts.length > 0 ? rtts.reduce((a, b) => a + b, 0) / rtts.length : 0;
                            
                            // Find MTU for this connection if available
                            const connMtu = mtuValues.find(m => m.connId === connId);
                            const mtuText = connMtu ? ` MTU: ${connMtu.mtu}` : '';
                            
                            tooltipLines.push(`[${shortId}] RTT: ${avgConnRtt.toFixed(2)}ms${mtuText}`);
                        });
                        const tooltip = tooltipLines.join('\n');
                        
                        // Node styling
                        // Highlight if there are multiple IPs at this hop (ECMP path variation)
                        const nodeColor = hasMultipleIps ? '#FF5722' : (connCount === connIds.length ? '#4CAF50' : '#FF9800');
                        const borderStyle = hasMultipleIps ? 'solid' : (connCount === connIds.length ? 'solid' : 'dashed');
                        const borderWidth = hasMultipleIps ? '3px' : '2px';
                        
                        html += `<div style="
                            position: relative;
                            background: ${nodeColor};
                            color: white;
                            padding: 8px 12px;
                            border-radius: 6px;
                            border: ${borderWidth} ${borderStyle} ${nodeColor};
                            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                            cursor: help;
                            font-size: 12px;
                            white-space: nowrap;
                            transition: transform 0.2s, box-shadow 0.2s;
                        " title="${tooltip}" onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.3)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.2)';">
                            <div style="font-weight: bold;">${ip}</div>
                            <div style="font-size: 10px; opacity: 0.9;">${avgRtt.toFixed(1)}ms avg</div>
                            <div style="font-size: 9px; opacity: 0.8;">${connCount}/${connIds.length} conn</div>
                            ${mtuRangeText ? `<div style="font-size: 9px; opacity: 0.8;">${mtuRangeText}</div>` : ''}
                        </div>`;
                    });
                }
                
                html += '</div></div>';
            }
            
            html += '</div>';
            
            // Add legend
            html += `<div style="margin-top: 20px; padding: 10px; background: #f9f9f9; border-radius: 4px; font-size: 12px;">
                <strong>Legend:</strong>
                <span style="margin-left: 15px;">
                    <span style="display: inline-block; width: 12px; height: 12px; background: #4CAF50; border: 2px solid #4CAF50; border-radius: 2px; margin-right: 5px;"></span>
                    All connections pass through (solid border)
                </span>
                <span style="margin-left: 15px;">
                    <span style="display: inline-block; width: 12px; height: 12px; background: #FF9800; border: 2px dashed #FF9800; border-radius: 2px; margin-right: 5px;"></span>
                    Partial connections (dashed border)
                </span>
                <span style="margin-left: 15px;">
                    <span style="display: inline-block; width: 12px; height: 12px; background: #FF5722; border: 3px solid #FF5722; border-radius: 2px; margin-right: 5px;"></span>
                    Multiple IPs at this hop (path variation)
                </span>
            </div>`;
            
            graphContainer.innerHTML = html;
        }
        
        // Make traceroute functions globally available
        window.addTracerouteHop = addTracerouteHop;
        window.addMtuHop = addMtuHop;
        window.clearTracerouteData = clearTracerouteData;
        
        // Peer connections data structure
        // Maps: ipVersion -> connIndex -> { conn_id, local_address, remote_address, udp_pairs }
        let peerConnectionsData = {
            ipv4: {},
            ipv6: {}
        };
        
        // Track unique UDP address pairs per connection (conn_id -> Set of "src_port -> dest_addr" strings)
        let connectionUdpPairs = {};
        
        // Helper function to determine IP version from conn_id
        // Returns 'ipv4' or 'ipv6' based on which bucket the connection is registered in
        function getIpVersionForConnId(connId) {
            // Check IPv4 connections
            for (const connInfo of Object.values(peerConnectionsData.ipv4)) {
                if (connInfo.conn_id === connId) {
                    return 'ipv4';
                }
            }
            
            // Check IPv6 connections
            for (const connInfo of Object.values(peerConnectionsData.ipv6)) {
                if (connInfo.conn_id === connId) {
                    return 'ipv6';
                }
            }
            
            // Fallback: try to determine from IP address if available
            return null;
        }
        
        // Helper function to escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Function to add a UDP address pair to a connection
        function addConnectionUdpPair(connId, srcPort, destAddr) {
            // Filter out unset values (srcPort of 0 indicates unset since valid ephemeral ports are > 0)
            if (!connId || srcPort === undefined || srcPort === null || !destAddr) return;
            
            if (!connectionUdpPairs[connId]) {
                connectionUdpPairs[connId] = new Set();
            }
            
            const pairKey = `${srcPort} ‚Üí ${destAddr}`;
            const hadPair = connectionUdpPairs[connId].has(pairKey);
            connectionUdpPairs[connId].add(pairKey);
            
            // Re-render if we added a new pair
            if (!hadPair) {
                renderPeerConnectionsList();
            }
        }
        
        // Function to register a peer connection
        function registerPeerConnection(ipVersion, connIndex, connId, localAddress, remoteAddress) {
            peerConnectionsData[ipVersion][connIndex] = {
                conn_id: connId,
                local_address: localAddress || 'Unknown',
                remote_address: remoteAddress || 'Unknown'
            };
            
            // Initialize UDP pairs tracking for this connection
            if (!connectionUdpPairs[connId]) {
                connectionUdpPairs[connId] = new Set();
            }
            
            // Update the UI
            renderPeerConnectionsList();
            
            // Update the table title with connection ID
            updateConnectionTitle(ipVersion, connIndex, connId);
        }
        
        // Function to update peer connection addresses (called when WebRTC provides actual addresses)
        function updatePeerConnectionAddresses(ipVersion, connIndex, localAddress, remoteAddress) {
            if (peerConnectionsData[ipVersion] && peerConnectionsData[ipVersion][connIndex]) {
                const conn = peerConnectionsData[ipVersion][connIndex];
                let changed = false;
                
                if (localAddress && localAddress !== conn.local_address) {
                    conn.local_address = localAddress;
                    changed = true;
                }
                if (remoteAddress && remoteAddress !== conn.remote_address) {
                    conn.remote_address = remoteAddress;
                    changed = true;
                }
                
                // Only re-render if something changed
                if (changed) {
                    renderPeerConnectionsList();
                }
            }
        }
        
        // Function to clear peer connections data
        function clearPeerConnectionsData() {
            peerConnectionsData.ipv4 = {};
            peerConnectionsData.ipv6 = {};
            connectionUdpPairs = {};
            renderPeerConnectionsList();
        }
        
        // Function to update connection title with conn_id
        function updateConnectionTitle(ipVersion, connIndex, connId) {
            const shortConnId = connId.length > 8 ? connId.substring(0, 8) : connId;
            const connIdEl = document.getElementById(`${ipVersion}-${connIndex}-conn-id`);
            if (connIdEl) {
                connIdEl.textContent = `[${shortConnId}]`;
                connIdEl.title = `Full Connection ID: ${connId}`;
            }
        }
        
        // Function to render the peer connections list
        function renderPeerConnectionsList() {
            const container = document.getElementById('peer-connections-list');
            if (!container) return;
            
            const allConnections = [];
            
            // Collect IPv4 connections
            for (const [index, connInfo] of Object.entries(peerConnectionsData.ipv4)) {
                allConnections.push({
                    ipVersion: 'IPv4',
                    index: parseInt(index),
                    ...connInfo
                });
            }
            
            // Collect IPv6 connections
            for (const [index, connInfo] of Object.entries(peerConnectionsData.ipv6)) {
                allConnections.push({
                    ipVersion: 'IPv6',
                    index: parseInt(index),
                    ...connInfo
                });
            }
            
            if (allConnections.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #999; padding: 20px; border: 1px dashed #ccc; border-radius: 4px;">No active connections. Click "Analyze Network" to start.</div>';
                return;
            }
            
            // Sort by IP version then by index
            allConnections.sort((a, b) => {
                if (a.ipVersion !== b.ipVersion) {
                    return a.ipVersion === 'IPv4' ? -1 : 1;
                }
                return a.index - b.index;
            });
            
            let html = '';
            for (const conn of allConnections) {
                const shortConnId = conn.conn_id.length > 8 ? conn.conn_id.substring(0, 8) : conn.conn_id;
                const bgColor = conn.ipVersion === 'IPv4' ? '#e3f2fd' : '#fff3e0';
                const borderColor = conn.ipVersion === 'IPv4' ? '#2196F3' : '#FF9800';
                
                // Get UDP pairs for this connection
                const udpPairs = connectionUdpPairs[conn.conn_id] || new Set();
                const udpPairsArray = Array.from(udpPairs);
                
                let udpPairsHtml = '';
                if (udpPairsArray.length > 0) {
                    udpPairsHtml = `
                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px dashed ${borderColor};">
                        <div style="font-size: 11px; color: #666; margin-bottom: 4px;"><strong>UDP Pairs (src ‚Üí dest):</strong></div>
                        <div style="font-size: 10px; font-family: monospace; max-height: 60px; overflow-y: auto; background: rgba(255,255,255,0.5); padding: 4px; border-radius: 3px;">
                            ${udpPairsArray.map(pair => `<div style="margin: 1px 0;">${escapeHtml(pair)}</div>`).join('')}
                        </div>
                    </div>`;
                }
                
                html += `
                <div style="background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 8px; padding: 12px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: ${borderColor};">
                        ${escapeHtml(conn.ipVersion)} Connection #${conn.index + 1}
                    </div>
                    <div style="font-size: 13px; margin-bottom: 6px;">
                        <strong>Conn ID:</strong> <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;" title="${escapeHtml(conn.conn_id)}">${escapeHtml(shortConnId)}</code>
                    </div>
                    <div style="font-size: 12px; color: #555;">
                        <div><strong>Local:</strong> ${escapeHtml(conn.local_address)}</div>
                        <div><strong>Remote:</strong> ${escapeHtml(conn.remote_address)}</div>
                    </div>
                    ${udpPairsHtml}
                </div>`;
            }
            
            container.innerHTML = html;
        }
        
        // Make peer connection functions globally available
        window.registerPeerConnection = registerPeerConnection;
        window.updatePeerConnectionAddresses = updatePeerConnectionAddresses;
        window.clearPeerConnectionsData = clearPeerConnectionsData;
        
        // Probe stats data storage
        let probeStatsData = {
            // conn_id -> { c2s_stats, s2c_stats, timestamp_ms, ipVersion }
        };
        
        // Probe stats chart
        let probeStatsChart = null;
        const probeStatsHistory = {
            timestamps: [],
            // conn_id -> { c2s_delay: [], c2s_jitter: [], s2c_delay: [], s2c_jitter: [], ... }
        };
        const MAX_PROBE_HISTORY = 60; // 60 seconds of history
        
        // Initialize probe stats chart
        function initProbeStatsChart() {
            const ctx = document.getElementById('probe-stats-chart');
            if (!ctx) return;
            
            probeStatsChart = new Chart(ctx.getContext('2d'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: {
                            type: 'time',
                            title: { display: true, text: 'Time' },
                            time: {
                                displayFormats: { second: 'HH:mm:ss' },
                                tooltipFormat: 'HH:mm:ss'
                            }
                        },
                        y: {
                            title: { display: true, text: 'Delay/Jitter (ms)' },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' },
                        zoom: {
                            pan: { enabled: true, mode: 'x' },
                            zoom: { wheel: { enabled: true, modifierKey: 'ctrl' }, mode: 'x' }
                        }
                    },
                    animation: false
                }
            });
        }
        
        // Initialize chart when window loads
        window.addEventListener('load', () => {
            setTimeout(initProbeStatsChart, 500); // Delay to ensure Chart.js is loaded
        });
        
        // Function to update probe stats visualization
        function updateProbeStats(statsData) {
            const connId = statsData.conn_id;
            const shortConnId = connId.length > 8 ? connId.substring(0, 8) : connId;
            
            // Determine IP version from registered connections
            let ipVersion = getIpVersionForConnId(connId);
            if (!ipVersion) ipVersion = 'ipv4'; // Default fallback
            
            // Store stats
            probeStatsData[connId] = {
                ...statsData,
                ipVersion
            };
            
            // Update history for charting
            const now = Date.now();
            if (!probeStatsHistory[connId]) {
                probeStatsHistory[connId] = {
                    c2s_delay: [], c2s_jitter: [], c2s_loss: [],
                    s2c_delay: [], s2c_jitter: [], s2c_loss: []
                };
            }
            
            const hist = probeStatsHistory[connId];
            hist.c2s_delay.push({ x: now, y: statsData.c2s_stats.delay_deviation_ms[0] || 0 });
            hist.c2s_jitter.push({ x: now, y: statsData.c2s_stats.jitter_ms[0] || 0 });
            hist.c2s_loss.push({ x: now, y: statsData.c2s_stats.loss_rate || 0 });
            hist.s2c_delay.push({ x: now, y: statsData.s2c_stats.delay_deviation_ms[0] || 0 });
            hist.s2c_jitter.push({ x: now, y: statsData.s2c_stats.jitter_ms[0] || 0 });
            hist.s2c_loss.push({ x: now, y: statsData.s2c_stats.loss_rate || 0 });
            
            // Trim old data
            Object.keys(hist).forEach(key => {
                while (hist[key].length > MAX_PROBE_HISTORY) {
                    hist[key].shift();
                }
            });
            
            // Render statistics panel
            renderProbeStatsPanel(ipVersion);
            
            // Update chart
            updateProbeStatsChart();
        }
        
        function renderProbeStatsPanel(ipVersion) {
            const container = document.getElementById(`probe-stats-${ipVersion}`);
            if (!container) return;
            
            // Get all connections of this IP version
            const conns = Object.entries(probeStatsData).filter(([_, data]) => data.ipVersion === ipVersion);
            
            if (conns.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #999;">Waiting for probe data...</div>';
                return;
            }
            
            let html = '<div style="display: grid; gap: 10px;">';
            
            for (const [connId, data] of conns) {
                const shortId = connId.length > 8 ? connId.substring(0, 8) : connId;
                const c2s = data.c2s_stats;
                const s2c = data.s2c_stats;
                
                html += `
                <div style="background: white; padding: 10px; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <div style="font-weight: bold; margin-bottom: 8px; font-size: 12px;">[${shortId}]</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 11px;">
                        <div>
                            <div style="font-weight: bold; color: #666; margin-bottom: 4px;">‚Üë C‚ÜíS</div>
                            <div>Delay: <span style="color: #2196F3;">${c2s.delay_deviation_ms[0].toFixed(1)}ms</span> (p99: ${c2s.delay_deviation_ms[1].toFixed(1)}ms)</div>
                            <div>Jitter: <span style="color: #2196F3;">${c2s.jitter_ms[0].toFixed(2)}ms</span></div>
                            <div>Loss: <span style="color: ${c2s.loss_rate > 1 ? '#f44336' : '#4caf50'};">${c2s.loss_rate.toFixed(2)}%</span></div>
                            <div>Reorder: ${c2s.reorder_rate.toFixed(2)}%</div>
                        </div>
                        <div>
                            <div style="font-weight: bold; color: #666; margin-bottom: 4px;">‚Üì S‚ÜíC</div>
                            <div>Delay: <span style="color: #FF9800;">${s2c.delay_deviation_ms[0].toFixed(1)}ms</span> (p99: ${s2c.delay_deviation_ms[1].toFixed(1)}ms)</div>
                            <div>Jitter: <span style="color: #FF9800;">${s2c.jitter_ms[0].toFixed(2)}ms</span></div>
                            <div>Loss: <span style="color: ${s2c.loss_rate > 1 ? '#f44336' : '#4caf50'};">${s2c.loss_rate.toFixed(2)}%</span></div>
                            <div>Reorder: ${s2c.reorder_rate.toFixed(2)}%</div>
                        </div>
                    </div>
                    <div style="margin-top: 6px; font-size: 10px; color: #999;">
                        Probes: C‚ÜíS ${c2s.probe_count}, S‚ÜíC ${s2c.probe_count} | Baseline: C‚ÜíS ${c2s.baseline_delay_ms.toFixed(1)}ms, S‚ÜíC ${s2c.baseline_delay_ms.toFixed(1)}ms
                    </div>
                </div>`;
            }
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function updateProbeStatsChart() {
            if (!probeStatsChart) return;
            
            const datasets = [];
            const colors = {
                ipv4: { c2s: 'rgba(33, 150, 243, 0.8)', s2c: 'rgba(33, 150, 243, 0.4)' },
                ipv6: { c2s: 'rgba(255, 152, 0, 0.8)', s2c: 'rgba(255, 152, 0, 0.4)' }
            };
            
            for (const [connId, hist] of Object.entries(probeStatsHistory)) {
                const data = probeStatsData[connId];
                if (!data) continue;
                
                const color = colors[data.ipVersion] || colors.ipv4;
                const shortId = connId.length > 8 ? connId.substring(0, 8) : connId;
                
                datasets.push({
                    label: `[${shortId}] C‚ÜíS Delay`,
                    data: hist.c2s_delay,
                    borderColor: color.c2s,
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.2,
                    pointRadius: 0
                });
                
                datasets.push({
                    label: `[${shortId}] S‚ÜíC Delay`,
                    data: hist.s2c_delay,
                    borderColor: color.s2c,
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    tension: 0.2,
                    pointRadius: 0
                });
            }
            
            probeStatsChart.data.datasets = datasets;
            probeStatsChart.update('none');
        }
        
        // Make probe stats function globally available
        window.updateProbeStats = updateProbeStats;
        
        // Function to generate metrics tables for multiple connections
        function generateMultiConnectionTables(connCount) {
            const container = document.getElementById('metrics-tables-container');
            if (!container) return;
            
            // If only 1 connection, use the default tables
            if (connCount <= 1) {
                document.getElementById('default-metrics').style.display = 'flex';
                return;
            }
            
            // Hide default metrics and create dynamic tables
            document.getElementById('default-metrics').style.display = 'none';
            
            // Clear any existing dynamic tables
            const existingDynamic = container.querySelectorAll('.dynamic-metrics');
            existingDynamic.forEach(el => el.remove());
            
            // Create a table for each connection pair (IPv4 + IPv6)
            for (let i = 0; i < connCount; i++) {
                const connDiv = document.createElement('div');
                connDiv.className = 'dual-stack-container dynamic-metrics';
                connDiv.style.marginBottom = '20px';
                connDiv.innerHTML = `
                    <div class="stack-column">
                        <h3>IPv4 Connection #${i + 1} <span id="ipv4-${i}-conn-id" style="font-size: 0.8em; color: #666;"></span></h3>
                        <table class="ipv4">
                            <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                            <tr><td>Throughput</td><td id="ipv4-${i}-s2c-tp-1">-</td><td id="ipv4-${i}-s2c-tp-10">-</td><td id="ipv4-${i}-s2c-tp-60">-</td></tr>
                            <tr><td>Delay (ms)</td><td id="ipv4-${i}-s2c-delay-1">-</td><td id="ipv4-${i}-s2c-delay-10">-</td><td id="ipv4-${i}-s2c-delay-60">-</td></tr>
                            <tr><td>Jitter (ms)</td><td id="ipv4-${i}-s2c-jitter-1">-</td><td id="ipv4-${i}-s2c-jitter-10">-</td><td id="ipv4-${i}-s2c-jitter-60">-</td></tr>
                            <tr><td>Loss Rate</td><td id="ipv4-${i}-s2c-loss-1">-</td><td id="ipv4-${i}-s2c-loss-10">-</td><td id="ipv4-${i}-s2c-loss-60">-</td></tr>
                            <tr><td>Reordering</td><td id="ipv4-${i}-s2c-reorder-1">-</td><td id="ipv4-${i}-s2c-reorder-10">-</td><td id="ipv4-${i}-s2c-reorder-60">-</td></tr>
                        </table>
                    </div>
                    <div class="stack-column">
                        <h3>IPv6 Connection #${i + 1} <span id="ipv6-${i}-conn-id" style="font-size: 0.8em; color: #666;"></span></h3>
                        <table class="ipv6">
                            <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                            <tr><td>Throughput</td><td id="ipv6-${i}-s2c-tp-1">-</td><td id="ipv6-${i}-s2c-tp-10">-</td><td id="ipv6-${i}-s2c-tp-60">-</td></tr>
                            <tr><td>Delay (ms)</td><td id="ipv6-${i}-s2c-delay-1">-</td><td id="ipv6-${i}-s2c-delay-10">-</td><td id="ipv6-${i}-s2c-delay-60">-</td></tr>
                            <tr><td>Jitter (ms)</td><td id="ipv6-${i}-s2c-jitter-1">-</td><td id="ipv6-${i}-s2c-jitter-10">-</td><td id="ipv6-${i}-s2c-jitter-60">-</td></tr>
                            <tr><td>Loss Rate</td><td id="ipv6-${i}-s2c-loss-1">-</td><td id="ipv6-${i}-s2c-loss-10">-</td><td id="ipv6-${i}-s2c-loss-60">-</td></tr>
                            <tr><td>Reordering</td><td id="ipv6-${i}-s2c-reorder-1">-</td><td id="ipv6-${i}-s2c-reorder-10">-</td><td id="ipv6-${i}-s2c-reorder-60">-</td></tr>
                        </table>
                    </div>
                `;
                container.appendChild(connDiv);
            }
        }
        
        // Function to update metrics for a specific connection
        function updateConnectionMetrics(ipVersion, connIndex, metrics) {
            const prefix = `${ipVersion}-${connIndex}-s2c`;
            const setBytesToKB = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = (value / 1024).toFixed(2) + ' KB/s';
            };
            const setMs = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value.toFixed(2);
            };
            const setPercent = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value.toFixed(2) + '%';
            };
            
            setBytesToKB(`${prefix}-tp-1`, metrics.s2c_throughput[0]);
            setBytesToKB(`${prefix}-tp-10`, metrics.s2c_throughput[1]);
            setBytesToKB(`${prefix}-tp-60`, metrics.s2c_throughput[2]);
            setMs(`${prefix}-delay-1`, metrics.s2c_delay_avg[0]);
            setMs(`${prefix}-delay-10`, metrics.s2c_delay_avg[1]);
            setMs(`${prefix}-delay-60`, metrics.s2c_delay_avg[2]);
            setMs(`${prefix}-jitter-1`, metrics.s2c_jitter[0]);
            setMs(`${prefix}-jitter-10`, metrics.s2c_jitter[1]);
            setMs(`${prefix}-jitter-60`, metrics.s2c_jitter[2]);
            setPercent(`${prefix}-loss-1`, metrics.s2c_loss_rate[0]);
            setPercent(`${prefix}-loss-10`, metrics.s2c_loss_rate[1]);
            setPercent(`${prefix}-loss-60`, metrics.s2c_loss_rate[2]);
            setPercent(`${prefix}-reorder-1`, metrics.s2c_reorder_rate[0]);
            setPercent(`${prefix}-reorder-10`, metrics.s2c_reorder_rate[1]);
            setPercent(`${prefix}-reorder-60`, metrics.s2c_reorder_rate[2]);
        }
        
        // Make functions globally available
        window.generateMultiConnectionTables = generateMultiConnectionTables;
        window.updateConnectionMetrics = updateConnectionMetrics;
        
        // Survey session tracking for survey-specific PCAP downloads
        let currentSurveySessionId = null;
        // Expose to window for upload functionality
        window.currentSurveySessionId = null;
        
        // Length of session ID prefix shown in UI (matches server-side truncation)
        const SESSION_ID_DISPLAY_LENGTH = 8;
        
        // Set the current survey session ID (called from WASM when session starts)
        function setSurveySessionId(sessionId) {
            currentSurveySessionId = sessionId;
            window.currentSurveySessionId = sessionId; // Expose for upload functionality
            const pcapBtn = document.getElementById('download-survey-pcap-btn');
            const pcapStatusEl = document.getElementById('survey-pcap-status');
            const keylogBtn = document.getElementById('download-survey-keylog-btn');
            const keylogStatusEl = document.getElementById('survey-keylog-status');
            
            if (sessionId && sessionId.length > 0) {
                const shortId = sessionId.length > SESSION_ID_DISPLAY_LENGTH 
                    ? sessionId.substring(0, SESSION_ID_DISPLAY_LENGTH) + '...' 
                    : sessionId;
                
                // Enable PCAP button
                pcapBtn.disabled = false;
                pcapBtn.style.backgroundColor = '#9C27B0';
                pcapBtn.style.cursor = 'pointer';
                pcapStatusEl.textContent = `Session: ${shortId}`;
                pcapStatusEl.style.color = '#9C27B0';
                
                // Enable Keylog button
                keylogBtn.disabled = false;
                keylogBtn.style.backgroundColor = '#673AB7';
                keylogBtn.style.cursor = 'pointer';
                keylogStatusEl.textContent = `Session: ${shortId}`;
                keylogStatusEl.style.color = '#673AB7';
            } else {
                // Disable PCAP button
                pcapBtn.disabled = true;
                pcapBtn.style.backgroundColor = '#ccc';
                pcapBtn.style.cursor = 'not-allowed';
                pcapStatusEl.textContent = 'Start a survey session first';
                pcapStatusEl.style.color = '#666';
                
                // Disable Keylog button
                keylogBtn.disabled = true;
                keylogBtn.style.backgroundColor = '#ccc';
                keylogBtn.style.cursor = 'not-allowed';
                keylogStatusEl.textContent = 'Start a survey session first';
                keylogStatusEl.style.color = '#666';
            }
        }
        
        // Download PCAP for current survey session
        function downloadSurveyPcap() {
            if (!currentSurveySessionId) {
                alert('No survey session active. Start "Analyze Network" first.');
                return;
            }
            
            const url = `/api/capture/download/session?survey_session_id=${encodeURIComponent(currentSurveySessionId)}`;
            window.location.href = url;
        }
        
        // Download DTLS keylog for current survey session
        function downloadSurveyKeylog() {
            if (!currentSurveySessionId) {
                alert('No survey session active. Start "Analyze Network" first.');
                return;
            }
            
            const url = `/api/keylog/download/session?survey_session_id=${encodeURIComponent(currentSurveySessionId)}`;
            window.location.href = url;
        }
        
        // Make survey functions globally available
        window.setSurveySessionId = setSurveySessionId;
        window.downloadSurveyPcap = downloadSurveyPcap;
        window.downloadSurveyKeylog = downloadSurveyKeylog;
    </script>
    <script type="module">
        const errorEl = document.getElementById('error');
        const statusEl = document.getElementById('status');
        const analyzeNetworkBtn = document.getElementById('analyze-network-btn');
        const stopTestingBtn = document.getElementById('stop-testing-btn');
        const wakeLockStatusEl = document.getElementById('wake-lock-status');

        // Update button states based on testing status
        function updateButtonStates(isTesting) {
            analyzeNetworkBtn.disabled = isTesting;
            stopTestingBtn.disabled = !isTesting;
        }

        // Check if Wake Lock API is supported
        function checkWakeLockSupport() {
            if ('wakeLock' in navigator) {
                wakeLockStatusEl.textContent = 'üîì Wake Lock: Ready';
                wakeLockStatusEl.className = '';
            } else {
                wakeLockStatusEl.textContent = '‚ö†Ô∏è Wake Lock: Not Supported';
                wakeLockStatusEl.className = 'unsupported';
            }
        }

        // Call on page load
        checkWakeLockSupport();
        
        // Check capture status and update UI
        async function checkCaptureStatus() {
            const captureStatusEl = document.getElementById('capture-status');
            const downloadBtn = document.getElementById('download-pcap-btn');
            
            try {
                const response = await fetch('/api/capture/stats', {
                    credentials: 'include',
                    mode: 'same-origin'
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.enabled && data.stats) {
                        const stats = data.stats;
                        captureStatusEl.textContent = `Capture active: ${stats.packets_in_buffer} packets buffered (${stats.total_captured} total captured)`;
                        captureStatusEl.style.color = '#4CAF50';
                        downloadBtn.style.backgroundColor = '#4CAF50';
                        downloadBtn.style.pointerEvents = 'auto';
                        downloadBtn.style.opacity = '1';
                    } else {
                        captureStatusEl.textContent = 'Capture disabled (enable in server config)';
                        captureStatusEl.style.color = '#999';
                        downloadBtn.style.backgroundColor = '#ccc';
                        downloadBtn.style.pointerEvents = 'none';
                        downloadBtn.style.opacity = '0.6';
                    }
                } else if (response.status === 401 || response.status === 403) {
                    captureStatusEl.textContent = 'Authentication required for capture stats';
                    captureStatusEl.style.color = '#ff9800';
                    downloadBtn.style.backgroundColor = '#ccc';
                    downloadBtn.style.pointerEvents = 'none';
                    downloadBtn.style.opacity = '0.6';
                } else {
                    captureStatusEl.textContent = 'Unable to check capture status';
                    captureStatusEl.style.color = '#f44336';
                }
            } catch (e) {
                captureStatusEl.textContent = 'Error checking capture status';
                captureStatusEl.style.color = '#f44336';
                console.error('Capture status check failed:', e);
            }
        }
        
        // Check tracing status and update UI
        async function checkTracingStatus() {
            const tracingStatusEl = document.getElementById('tracing-status');
            const downloadBtn = document.getElementById('download-tracing-btn');
            
            try {
                const response = await fetch('/api/tracing/stats', {
                    credentials: 'include',
                    mode: 'same-origin'
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.enabled) {
                        tracingStatusEl.textContent = `Tracing active: ${data.entries_in_buffer} entries buffered (max: ${data.max_entries})`;
                        tracingStatusEl.style.color = '#2196F3';
                        downloadBtn.style.backgroundColor = '#2196F3';
                        downloadBtn.style.pointerEvents = 'auto';
                        downloadBtn.style.opacity = '1';
                    } else {
                        tracingStatusEl.textContent = 'Tracing disabled (enable in server config)';
                        tracingStatusEl.style.color = '#999';
                        downloadBtn.style.backgroundColor = '#ccc';
                        downloadBtn.style.pointerEvents = 'none';
                        downloadBtn.style.opacity = '0.6';
                    }
                } else if (response.status === 401 || response.status === 403) {
                    tracingStatusEl.textContent = 'Authentication required for tracing stats';
                    tracingStatusEl.style.color = '#ff9800';
                    downloadBtn.style.backgroundColor = '#ccc';
                    downloadBtn.style.pointerEvents = 'none';
                    downloadBtn.style.opacity = '0.6';
                } else {
                    tracingStatusEl.textContent = 'Unable to check tracing status';
                    tracingStatusEl.style.color = '#f44336';
                }
            } catch (e) {
                tracingStatusEl.textContent = 'Error checking tracing status';
                tracingStatusEl.style.color = '#f44336';
                console.error('Tracing status check failed:', e);
            }
        }
        
        // Check capture status on page load
        checkCaptureStatus();
        
        // Check tracing status on page load
        checkTracingStatus();
        
        // Periodically update capture and tracing status (every 5 seconds)
        setInterval(checkCaptureStatus, 5000);
        setInterval(checkTracingStatus, 5000);

        // Check auth type and show/hide full auth only buttons
        async function checkAuthTypeAndShowButtons() {
            try {
                const response = await fetch('/api/auth/status');
                if (response.ok) {
                    const data = await response.json();
                    // Only show Download PCAP and Download Tracing Log buttons for full auth users
                    if (data.auth_type === 'full') {
                        document.getElementById('download-pcap-container').style.display = 'flex';
                        document.getElementById('download-tracing-container').style.display = 'flex';
                    } else {
                        // For magic key users or unauthenticated, hide these buttons
                        document.getElementById('download-pcap-container').style.display = 'none';
                        document.getElementById('download-tracing-container').style.display = 'none';
                    }
                }
            } catch (e) {
                console.log('Error checking auth status:', e);
                // Hide buttons on error
                document.getElementById('download-pcap-container').style.display = 'none';
                document.getElementById('download-tracing-container').style.display = 'none';
            }
        }
        
        // Check auth type on page load
        checkAuthTypeAndShowButtons();

        // Issue 014: Wrap in DOMContentLoaded to ensure DOM is ready before initializing
        document.addEventListener('DOMContentLoaded', async () => {
            // Wrap in async IIFE for better Safari compatibility
            (async () => {
                try {
                    // Cache-busting timestamp
                    const cacheBuster = Date.now();

                    // Import the JS wrapper (without cache-busting query param for Safari compatibility)
                    const module = await import('/public/pkg/netpoke_client.js');
                    const { default: init, start_measurement, start_measurement_with_count, analyze_path, analyze_path_with_count, analyze_network, analyze_network_with_count, stop_testing, is_testing_active, init_recorder, recorder_render_frame, on_gps_update, on_orientation, on_motion, on_magnetometer, download_video, download_motion_data, delete_recording_by_id } = module;

                    // Initialize WASM with explicit path and cache-busting
                    // Pass the .wasm file path to init() for Safari compatibility
                    await init(`/public/pkg/netpoke_client_bg.wasm?v=${cacheBuster}`);
                    console.log('WASM module loaded successfully');

                    // Initialize recorder
                    init_recorder();
                    console.log('Recorder initialized');

                    // Check if screen capture is supported (getDisplayMedia)
                    // iOS Safari does not support getDisplayMedia, so disable Screen and Combined modes
                    const isScreenCaptureSupported = navigator.mediaDevices && 
                        typeof navigator.mediaDevices.getDisplayMedia === 'function';
                    
                    if (!isScreenCaptureSupported) {
                        console.log('Screen capture not supported - disabling Screen and Combined recording modes');
                        
                        // Disable Screen Only mode
                        const screenRadio = document.getElementById('mode-screen');
                        if (screenRadio) {
                            screenRadio.disabled = true;
                            const screenLabel = screenRadio.parentElement;
                            if (screenLabel) {
                                screenLabel.style.opacity = '0.5';
                                screenLabel.style.cursor = 'not-allowed';
                                screenLabel.title = 'Screen capture is not supported on this device';
                            }
                        }
                        
                        // Disable Combined (PiP) mode
                        const combinedRadio = document.getElementById('mode-combined');
                        if (combinedRadio) {
                            combinedRadio.disabled = true;
                            // Uncheck if it was the default selection
                            if (combinedRadio.checked) {
                                combinedRadio.checked = false;
                            }
                            const combinedLabel = combinedRadio.parentElement;
                            if (combinedLabel) {
                                combinedLabel.style.opacity = '0.5';
                                combinedLabel.style.cursor = 'not-allowed';
                                combinedLabel.title = 'Screen capture is not supported on this device';
                            }
                        }
                        
                        // Auto-select Camera mode since it's the only supported option
                        const cameraRadio = document.getElementById('mode-camera');
                        if (cameraRadio) {
                            cameraRadio.checked = true;
                            // Trigger change event to update recorder state
                            cameraRadio.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
                        }
                        
                        // Hide PiP controls since Combined mode is not available
                        const pipControls = document.getElementById('pip-controls');
                        if (pipControls) {
                            pipControls.style.display = 'none';
                        }
                    }

                // Expose recorder_render_frame to global scope for render loop
                window.recorder_render_frame = recorder_render_frame;

                // Helper function to check if recording is active
                const isRecordingActive = () => {
                    const statusBadge = document.getElementById('recording-status');
                    return statusBadge && statusBadge.classList.contains('recording');
                };

                // Helper functions to hide/show chart legends for video capture
                // When capturing charts for video, we hide the legend so only the graph is shown
                const hideChartsLegendForCapture = () => {
                    if (typeof metricsChart !== 'undefined' && metricsChart) {
                        metricsChart.options.plugins.legend.display = false;
                        metricsChart.update('none');
                    }
                    if (typeof probeStatsChart !== 'undefined' && probeStatsChart) {
                        probeStatsChart.options.plugins.legend.display = false;
                        probeStatsChart.update('none');
                    }
                };

                const restoreChartsLegend = () => {
                    if (typeof metricsChart !== 'undefined' && metricsChart) {
                        metricsChart.options.plugins.legend.display = true;
                        metricsChart.update('none');
                    }
                    if (typeof probeStatsChart !== 'undefined' && probeStatsChart) {
                        probeStatsChart.options.plugins.legend.display = true;
                        probeStatsChart.update('none');
                    }
                };

                // Set up render loop for recorder (30 FPS)
                let renderLoopId = null;
                const renderLoop = () => {
                    if (window.recorder_render_frame) {
                        // If recording, hide legend before capturing frame
                        const recording = isRecordingActive();
                        if (recording) {
                            hideChartsLegendForCapture();
                        }
                        
                        window.recorder_render_frame();
                        
                        // Restore legend after capturing so user still sees it
                        if (recording) {
                            restoreChartsLegend();
                        }
                    }
                    renderLoopId = requestAnimationFrame(renderLoop);
                };
                renderLoop();

                // Issue 008: Sensor tracking functions
                let watchId = null;
                let orientationListener = null;
                let motionListener = null;
                let magnetometerListener = null;
                let sensorListenersActive = false;

                async function requestSensorPermissions() {
                    // iOS requires explicit permission request
                    if (typeof DeviceOrientationEvent !== 'undefined' &&
                        typeof DeviceOrientationEvent.requestPermission === 'function') {
                        try {
                            const response = await DeviceOrientationEvent.requestPermission();
                            if (response !== 'granted') {
                                console.warn('DeviceOrientation permission denied');
                                return false;
                            }
                        } catch (e) {
                            console.error('Error requesting DeviceOrientation permission:', e);
                            return false;
                        }
                    }
                    if (typeof DeviceMotionEvent !== 'undefined' &&
                        typeof DeviceMotionEvent.requestPermission === 'function') {
                        try {
                            const response = await DeviceMotionEvent.requestPermission();
                            if (response !== 'granted') {
                                console.warn('DeviceMotion permission denied');
                                return false;
                            }
                        } catch (e) {
                            console.error('Error requesting DeviceMotion permission:', e);
                            return false;
                        }
                    }
                    
                    // CRITICAL: Add event listeners immediately after permission granted (iOS requirement)
                    // Must be in same synchronous task, before any await
                    if (!sensorListenersActive) {
                        // Orientation listener
                        orientationListener = (event) => {
                            // iOS Safari provides compass heading in alpha but doesn't set absolute=true
                            // Always treat alpha as compass heading on iOS if we have a value
                            const hasCompass = event.alpha !== null && event.alpha !== undefined;
                            const effectiveAbsolute = event.absolute || hasCompass;
                            
                            on_orientation(
                                event.alpha,
                                event.beta,
                                event.gamma,
                                effectiveAbsolute
                            );
                            // iOS Safari provides compass in alpha even without absolute flag
                            if (hasCompass && on_magnetometer) {
                                on_magnetometer(
                                    event.alpha,
                                    event.beta,
                                    event.gamma,
                                    effectiveAbsolute
                                );
                            }
                            // Update UI display (matching old code)
                            const orientEl = document.getElementById('orientation');
                            if (orientEl) {
                                orientEl.textContent = `Œ±:${event.alpha?.toFixed(0) || '-'}¬∞ Œ≤:${event.beta?.toFixed(0) || '-'}¬∞ Œ≥:${event.gamma?.toFixed(0) || '-'}¬∞`;
                            }
                        };
                        window.addEventListener('deviceorientation', orientationListener);
                        
                        // Motion listener
                        motionListener = (event) => {
                            const timestamp = new Date().toISOString();
                            const currentTime = Date.now();
                            const accel = event.acceleration || { x: 0, y: 0, z: 0 };
                            const accelG = event.accelerationIncludingGravity || { x: 0, y: 0, z: 0 };
                            const rot = event.rotationRate || { alpha: 0, beta: 0, gamma: 0 };
                            on_motion(
                                timestamp,
                                currentTime,
                                accel.x || 0, accel.y || 0, accel.z || 0,
                                accelG.x || 0, accelG.y || 0, accelG.z || 0,
                                rot.alpha || 0, rot.beta || 0, rot.gamma || 0
                            );
                            // Update UI display (matching old code)
                            const accelEl = document.getElementById('acceleration');
                            if (accelEl && accel) {
                                accelEl.textContent = `x:${(accel.x || 0).toFixed(2)} y:${(accel.y || 0).toFixed(2)} z:${(accel.z || 0).toFixed(2)}`;
                            }
                        };
                        window.addEventListener('devicemotion', motionListener);
                        
                        // Magnetometer (absolute orientation) listener
                        magnetometerListener = (event) => {
                            if (on_magnetometer && event.alpha !== null) {
                                on_magnetometer(
                                    event.alpha,
                                    event.beta,
                                    event.gamma,
                                    true  // absolute = true for deviceorientationabsolute
                                );
                            }
                            // Update UI display (matching old code)
                            const magEl = document.getElementById('magnetometer');
                            if (magEl) {
                                magEl.textContent = `heading:${event.alpha?.toFixed(0) || '-'}¬∞ Œ≤:${event.beta?.toFixed(0) || '-'}¬∞ Œ≥:${event.gamma?.toFixed(0) || '-'}¬∞`;
                            }
                        };
                        window.addEventListener('deviceorientationabsolute', magnetometerListener);
                        
                        sensorListenersActive = true;
                    }
                    
                    return true;
                }

                function startSensorTracking() {
                    console.log('[Sensors] Starting sensor tracking');
                    
                    // Start GPS (event listeners already added by requestSensorPermissions)
                    if (navigator.geolocation) {
                        watchId = navigator.geolocation.watchPosition(
                            (position) => {
                                on_gps_update(
                                    position.coords.latitude,
                                    position.coords.longitude,
                                    position.coords.accuracy,
                                    position.coords.altitude,
                                    position.coords.altitudeAccuracy,
                                    position.coords.heading,
                                    position.coords.speed
                                );
                                // Update UI display (matching old code)
                                const gpsEl = document.getElementById('gps');
                                if (gpsEl) {
                                    gpsEl.textContent = `${position.coords.latitude.toFixed(6)}, ${position.coords.longitude.toFixed(6)} ¬±${position.coords.accuracy.toFixed(1)}m`;
                                }
                            },
                            (error) => {
                                console.warn('GPS error:', error);
                                // Update UI display on error (matching old code)
                                const gpsEl = document.getElementById('gps');
                                if (gpsEl) {
                                    gpsEl.textContent = 'error: ' + error.message;
                                }
                            },
                            { enableHighAccuracy: true, maximumAge: 1000 }
                        );
                    }
                }

                function stopSensorTracking() {
                    console.log('[Sensors] Stopping sensor tracking');
                    if (watchId !== null) {
                        navigator.geolocation.clearWatch(watchId);
                        watchId = null;
                    }
                    if (orientationListener) {
                        window.removeEventListener('deviceorientation', orientationListener);
                        orientationListener = null;
                    }
                    if (motionListener) {
                        window.removeEventListener('devicemotion', motionListener);
                        motionListener = null;
                    }
                    if (magnetometerListener) {
                        window.removeEventListener('deviceorientationabsolute', magnetometerListener);
                        magnetometerListener = null;
                    }
                    sensorListenersActive = false;
                }

                // Expose sensor functions globally
                window.requestSensorPermissions = requestSensorPermissions;
                window.startSensorTracking = startSensorTracking;
                window.stopSensorTracking = stopSensorTracking;

                // Issue 011: Function to refresh recordings list
                async function refreshRecordingsList() {
                    console.log('[Recorder] Refreshing recordings list');
                    
                    const container = document.getElementById('recordings-container');
                    if (!container) {
                        console.warn('[Recorder] recordings-container not found');
                        return;
                    }
                    
                    try {
                        // Use existing WASM storage module to get all recordings
                        // Must match indexed_db.js: NetpokeRecordingsDB version 1
                        const dbName = 'NetpokeRecordingsDB';
                        const storeName = 'recordings';
                        
                        // Open IndexedDB
                        const db = await new Promise((resolve, reject) => {
                            const request = indexedDB.open(dbName, 1);
                            request.onerror = () => reject(request.error);
                            request.onsuccess = () => resolve(request.result);
                            request.onupgradeneeded = (event) => {
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains(storeName)) {
                                    db.createObjectStore(storeName, { keyPath: 'id' });
                                }
                            };
                        });
                        
                        // Get all recordings
                        const recordings = await new Promise((resolve, reject) => {
                            const transaction = db.transaction([storeName], 'readonly');
                            const store = transaction.objectStore(storeName);
                            const request = store.getAll();
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                        
                        // Close database
                        db.close();
                        
                        if (recordings.length === 0) {
                            container.innerHTML = '<p style="color:#888;">No recordings yet. Start a recording to see it listed here.</p>';
                            return;
                        }
                        
                        // Generate HTML for each recording
                        container.innerHTML = recordings
                            .sort((a, b) => b.timestamp - a.timestamp) // Most recent first
                            .map(rec => {
                                const date = new Date(rec.timestamp);
                                const sizeInMB = (rec.videoBlob.size / (1024 * 1024)).toFixed(2);
                                const sensorSizeKB = rec.sensorData ? (JSON.stringify(rec.sensorData).length / 1024).toFixed(1) : '0';
                                const sourceType = rec.metadata.source_type || 'camera';
                                const sourceClass = `source-${sourceType}`;
                                const sourceLabel = sourceType.charAt(0).toUpperCase() + sourceType.slice(1);
                                const notes = rec.notes || '';
                                const uploadStatus = rec.uploadStatus || '';
                                
                                return `
                                    <div class="recording-item" data-recording-id="${rec.id}">
                                        <div class="recording-row">
                                            <div class="recording-info">
                                                <div class="data"><strong>ID:</strong> ${rec.id} <span class="source-label ${sourceClass}">${sourceLabel}</span></div>
                                                <div class="data"><strong>Date:</strong> ${date.toLocaleString()}</div>
                                                <div class="data"><strong>Duration:</strong> ${rec.metadata.duration.toFixed(1)}s</div>
                                                <div class="data"><strong>Frames:</strong> ${rec.metadata.frameCount}</div>
                                                <div class="data"><strong>Size:</strong> ${sizeInMB} MB (video) + ${sensorSizeKB} KB (sensors)</div>
                                                ${notes ? `<div class="recording-notes">"${notes}"</div>` : ''}
                                            </div>
                                            <div class="recording-actions">
                                                <button onclick="window.editNotesWrapper('${rec.id}')" class="btn-notes">‚úèÔ∏è Notes</button>
                                                <button onclick="window.startUploadWrapper('${rec.id}')" 
                                                        id="upload-btn-${rec.id}" 
                                                        class="btn-upload ${uploadStatus === 'complete' ? 'success' : ''}"
                                                        ${uploadStatus === 'complete' ? 'disabled' : ''}>
                                                    ${uploadStatus === 'complete' ? '‚úì Uploaded' : 'üì§ Upload'}
                                                </button>
                                                <button onclick="window.downloadVideoWrapper('${rec.id}')" class="btn-download">Download Video</button>
                                                <button onclick="window.downloadMotionDataWrapper('${rec.id}')" class="btn-download">Download Motion</button>
                                                <button onclick="window.deleteRecordingWrapper('${rec.id}')" class="btn-delete danger">Delete</button>
                                            </div>
                                        </div>
                                        <div class="upload-progress" id="progress-${rec.id}" style="display:none;">
                                            <div class="progress-bar">
                                                <div class="progress-fill" style="width: 0%"></div>
                                            </div>
                                            <span class="progress-text">Preparing upload...</span>
                                        </div>
                                    </div>
                                `;
                            }).join('');
                            
                        console.log(`[Recorder] Displayed ${recordings.length} recording(s)`);
                        
                    } catch (error) {
                        console.error('[Recorder] Error refreshing recordings list:', error);
                        container.innerHTML = `<p style="color:#f44;">Error loading recordings: ${error.message}</p>`;
                    }
                }
                window.refreshRecordingsList = refreshRecordingsList;

                // Load existing recordings from IndexedDB
                await refreshRecordingsList();
                console.log('Recordings list loaded');

                // Wrapper functions to bridge HTML onclick handlers to WASM functions
                window.downloadVideoWrapper = async function(id) {
                    try {
                        await download_video(id);
                    } catch (error) {
                        console.error('[Recorder] Error downloading video:', error);
                        alert('Error downloading video: ' + error.message);
                    }
                };

                window.downloadMotionDataWrapper = async function(id) {
                    try {
                        await download_motion_data(id);
                    } catch (error) {
                        console.error('[Recorder] Error downloading motion data:', error);
                        alert('Error downloading motion data: ' + error.message);
                    }
                };

                window.deleteRecordingWrapper = async function(id) {
                    try {
                        await delete_recording_by_id(id);
                        // List will be refreshed by the WASM code after successful deletion
                    } catch (error) {
                        console.error('[Recorder] Error deleting recording:', error);
                        alert('Error deleting recording: ' + error.message);
                    }
                };

                // Upload constants
                const CHUNK_SIZE = 1048576; // 1 MB

                // SHA-256 helper using Web Crypto API
                async function calculateSHA256(data) {
                    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                    const hashArray = Array.from(new Uint8Array(hashBuffer));
                    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                }

                // Get recording from IndexedDB by ID
                async function getRecordingFromDB(recordingId) {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open('NetpokeRecordingsDB', 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => {
                            const db = request.result;
                            const transaction = db.transaction(['recordings'], 'readonly');
                            const store = transaction.objectStore('recordings');
                            const getRequest = store.get(recordingId);
                            getRequest.onerror = () => reject(getRequest.error);
                            getRequest.onsuccess = () => {
                                db.close();
                                resolve(getRequest.result);
                            };
                        };
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('recordings')) {
                                db.createObjectStore('recordings', { keyPath: 'id' });
                            }
                        };
                    });
                }

                // Update recording in IndexedDB
                async function updateRecordingInDB(recording) {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open('NetpokeRecordingsDB', 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => {
                            const db = request.result;
                            const transaction = db.transaction(['recordings'], 'readwrite');
                            const store = transaction.objectStore('recordings');
                            const putRequest = store.put(recording);
                            putRequest.onerror = () => reject(putRequest.error);
                            putRequest.onsuccess = () => {
                                db.close();
                                resolve();
                            };
                        };
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('recordings')) {
                                db.createObjectStore('recordings', { keyPath: 'id' });
                            }
                        };
                    });
                }

                // Edit notes for a recording
                window.editNotesWrapper = async function(recordingId) {
                    try {
                        const recording = await getRecordingFromDB(recordingId);
                        if (!recording) {
                            alert('Recording not found');
                            return;
                        }

                        const currentNotes = recording.notes || '';
                        const newNotes = prompt('Enter notes for this recording:', currentNotes);
                        
                        if (newNotes !== null) {
                            recording.notes = newNotes;
                            await updateRecordingInDB(recording);
                            await refreshRecordingsList();
                        }
                    } catch (error) {
                        console.error('[Upload] Error editing notes:', error);
                        alert('Error editing notes: ' + error.message);
                    }
                };

                // Calculate checksums for all chunks in a blob
                async function calculateAllChunkChecksums(blob) {
                    const checksums = [];
                    const totalChunks = Math.ceil(blob.size / CHUNK_SIZE);

                    for (let i = 0; i < totalChunks; i++) {
                        const start = i * CHUNK_SIZE;
                        const end = Math.min(start + CHUNK_SIZE, blob.size);
                        const chunk = blob.slice(start, end);
                        const chunkData = await chunk.arrayBuffer();
                        const checksum = await calculateSHA256(chunkData);
                        checksums.push(checksum);
                    }

                    return checksums;
                }

                // Upload a single file with chunked transfer and resume
                async function uploadFile(blob, recordingId, fileType, existingChunks, onProgress) {
                    const totalChunks = Math.ceil(blob.size / CHUNK_SIZE);

                    for (let i = 0; i < totalChunks; i++) {
                        const start = i * CHUNK_SIZE;
                        const end = Math.min(start + CHUNK_SIZE, blob.size);
                        const chunk = blob.slice(start, end);
                        const chunkData = await chunk.arrayBuffer();
                        const checksum = await calculateSHA256(chunkData);

                        // Skip if server already has this chunk with matching checksum
                        if (existingChunks && existingChunks[i] && 
                            existingChunks[i].checksum === checksum) {
                            onProgress(Math.round(((i + 1) / totalChunks) * 100));
                            continue;
                        }

                        // Upload chunk with retry
                        let retries = 3;
                        while (retries > 0) {
                            try {
                                const response = await fetch('/api/upload/chunk', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/octet-stream',
                                        'X-Recording-Id': recordingId,
                                        'X-File-Type': fileType,
                                        'X-Chunk-Index': i.toString(),
                                        'X-Chunk-Checksum': checksum
                                    },
                                    body: chunkData
                                });

                                if (!response.ok) {
                                    throw new Error(`HTTP ${response.status}`);
                                }
                                break; // Success, exit retry loop
                            } catch (err) {
                                retries--;
                                if (retries === 0) throw err;
                                await new Promise(r => setTimeout(r, 1000)); // Wait 1s before retry
                            }
                        }

                        onProgress(Math.round(((i + 1) / totalChunks) * 100));
                    }
                }

                // Start upload for a recording
                window.startUploadWrapper = async function(recordingId) {
                    const recording = await getRecordingFromDB(recordingId);
                    if (!recording) {
                        alert('Recording not found');
                        return;
                    }

                    // Check if we have a survey session ID
                    const surveySessionId = window.currentSurveySessionId;
                    if (!surveySessionId) {
                        alert('No active survey session. Please start a survey before uploading.');
                        return;
                    }

                    const button = document.getElementById(`upload-btn-${recordingId}`);
                    const progressDiv = document.getElementById(`progress-${recordingId}`);
                    const progressFill = progressDiv.querySelector('.progress-fill');
                    const progressText = progressDiv.querySelector('.progress-text');

                    // Disable button and show progress
                    button.disabled = true;
                    button.classList.add('uploading');
                    progressDiv.style.display = 'block';
                    progressText.textContent = 'Preparing upload...';

                    try {
                        // Create sensor data blob
                        const sensorBlob = new Blob(
                            [JSON.stringify(recording.sensorData || [])], 
                            { type: 'application/json' }
                        );
                        
                        const deviceInfo = {
                            browser: navigator.userAgent,
                            os: navigator.platform,
                            screen_width: window.screen.width,
                            screen_height: window.screen.height,
                            source_type: recording.metadata.source_type || 'camera',
                            duration: recording.metadata.duration,
                            frameCount: recording.metadata.frameCount
                        };

                        // Step 1: Prepare upload
                        const prepareReq = {
                            session_id: surveySessionId,
                            recording_id: recordingId,
                            video_size_bytes: recording.videoBlob.size,
                            sensor_size_bytes: sensorBlob.size,
                            device_info: deviceInfo,
                            user_notes: recording.notes || null
                        };

                        const prepareResp = await fetch('/api/upload/prepare', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(prepareReq)
                        });

                        if (!prepareResp.ok) {
                            let errorMsg = `Upload failed: HTTP ${prepareResp.status}`;
                            try {
                                const errorData = await prepareResp.json();
                                if (errorData.error) {
                                    errorMsg = errorData.error;
                                }
                            } catch (e) {
                                // Response wasn't JSON, use status-based messages
                                if (prepareResp.status === 503) {
                                    errorMsg = 'Upload service unavailable - server may not be fully configured';
                                } else if (prepareResp.status === 404) {
                                    errorMsg = 'Session not found - please start a survey first';
                                }
                            }
                            throw new Error(errorMsg);
                        }
                        const prepareData = await prepareResp.json();

                        // Step 2: Upload video chunks
                        progressText.textContent = 'Uploading video...';
                        await uploadFile(
                            recording.videoBlob,
                            recordingId,
                            'video',
                            prepareData.video_chunks,
                            (progress) => {
                                progressFill.style.width = `${progress}%`;
                                progressText.textContent = `Uploading video: ${progress}%`;
                            }
                        );

                        // Step 3: Upload sensor data
                        progressText.textContent = 'Uploading sensors...';
                        await uploadFile(
                            sensorBlob,
                            recordingId,
                            'sensor',
                            prepareData.sensor_chunks,
                            (progress) => {
                                progressFill.style.width = `${progress}%`;
                                progressText.textContent = `Uploading sensors: ${progress}%`;
                            }
                        );

                        // Step 4: Finalize
                        progressText.textContent = 'Verifying upload...';
                        const videoChecksums = await calculateAllChunkChecksums(recording.videoBlob);
                        const sensorChecksums = await calculateAllChunkChecksums(sensorBlob);

                        const videoFinalChecksum = await calculateSHA256(
                            new TextEncoder().encode(videoChecksums.join(''))
                        );
                        const sensorFinalChecksum = await calculateSHA256(
                            new TextEncoder().encode(sensorChecksums.join(''))
                        );

                        const finalizeResp = await fetch('/api/upload/finalize', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                recording_id: recordingId,
                                video_final_checksum: videoFinalChecksum,
                                sensor_final_checksum: sensorFinalChecksum
                            })
                        });

                        if (!finalizeResp.ok) {
                            let errorMsg = `Finalize failed: HTTP ${finalizeResp.status}`;
                            try {
                                const errorData = await finalizeResp.json();
                                if (errorData.error) {
                                    errorMsg = errorData.error;
                                }
                            } catch (e) {
                                // Response wasn't JSON
                            }
                            throw new Error(errorMsg);
                        }

                        const finalizeData = await finalizeResp.json();
                        if (finalizeData.status !== 'complete') {
                            throw new Error('Verification failed');
                        }

                        // Success - update recording status
                        recording.uploadStatus = 'complete';
                        await updateRecordingInDB(recording);

                        progressFill.style.width = '100%';
                        progressText.textContent = '‚úì Upload complete';
                        button.textContent = '‚úì Uploaded';
                        button.classList.remove('uploading');
                        button.classList.add('success');

                        console.log(`[Upload] Recording ${recordingId} uploaded successfully`);

                    } catch (error) {
                        console.error('[Upload] Upload failed:', error);
                        progressText.textContent = `‚ö†Ô∏è Upload failed: ${error.message}`;
                        button.disabled = false;
                        button.classList.remove('uploading');
                        button.classList.add('error');
                        button.textContent = '‚ö†Ô∏è Retry Upload';
                    }
                };

                // Issue 009: Function to handle screen share stop
                window.onScreenShareStopped = function() {
                    console.log('[Recorder] Screen sharing stopped by user');
                    // The stop_recording function would be called from the Rust side
                    // This is just a placeholder for the JavaScript callback
                };

                statusEl.textContent = 'Ready';
                statusEl.className = '';
                
                // Get connection count from dropdown
                const getConnCount = () => {
                    const select = document.getElementById('conn-count');
                    return parseInt(select.value, 10) || 1;
                };

                window.analyzeNetwork = async function() {
                    statusEl.textContent = 'Starting network analysis...';
                    statusEl.className = '';
                    errorEl.textContent = '';
                    
                    // Update button states - disable analyze, enable stop
                    updateButtonStates(true);
                    
                    // Clear the server messages textarea
                    const serverMessagesEl = document.getElementById('server-messages');
                    if (serverMessagesEl) {
                        serverMessagesEl.value = '';
                    }
                    
                    // Clear traceroute visualization
                    if (window.clearTracerouteData) {
                        window.clearTracerouteData();
                    }
                    
                    // Clear peer connections data
                    if (window.clearPeerConnectionsData) {
                        window.clearPeerConnectionsData();
                    }
                    
                    const connCount = getConnCount();
                    console.log(`Starting network analysis with ${connCount} connections per address family`);
                    
                    // Generate dynamic tables for multi-connection display
                    if (window.generateMultiConnectionTables) {
                        window.generateMultiConnectionTables(connCount);
                    }

                    try {
                        // Update status to show phase 1 (traceroute)
                        statusEl.textContent = `Phase 1: Analyzing network paths (traceroute) with ${connCount} connection(s)...`;
                        statusEl.className = 'running';
                        
                        // Update wake lock status
                        if ('wakeLock' in navigator) {
                            wakeLockStatusEl.textContent = 'üîí Wake Lock: Active';
                            wakeLockStatusEl.className = 'active';
                        }
                        
                        // Start the combined analysis
                        await analyze_network_with_count(connCount);
                        
                        // Update UI to show measurements are now running
                        statusEl.textContent = `Running ongoing network measurements with ${connCount} concurrent WebRTC connection(s)...`;
                        statusEl.className = 'running';
                        
                    } catch (e) {
                        const errMsg = 'Network analysis error: ' + (e.message || e);
                        statusEl.textContent = 'Error';
                        statusEl.className = 'error';
                        errorEl.textContent = errMsg;
                        console.error('Network analysis error:', e);
                        
                        // Update button states - enable analyze, disable stop
                        updateButtonStates(false);
                        
                        // Update wake lock status
                        if ('wakeLock' in navigator) {
                            wakeLockStatusEl.textContent = 'üîì Wake Lock: Ready';
                            wakeLockStatusEl.className = '';
                        }
                    }
                };
                
                // Stop testing function
                window.stopTesting = function() {
                    console.log('Stopping network testing...');
                    
                    try {
                        // Call the WASM stop_testing function
                        stop_testing();
                        
                        // Update UI
                        statusEl.textContent = 'Testing stopped';
                        statusEl.className = '';
                        
                        // Update button states - enable analyze, disable stop
                        updateButtonStates(false);
                        
                        // Update wake lock status
                        if ('wakeLock' in navigator) {
                            wakeLockStatusEl.textContent = 'üîì Wake Lock: Ready';
                            wakeLockStatusEl.className = '';
                        }
                        
                        console.log('Testing stopped successfully');
                    } catch (e) {
                        console.error('Error stopping testing:', e);
                        errorEl.textContent = 'Error stopping testing: ' + (e.message || e);
                    }
                };
            } catch (e) {
                const errMsg = 'Failed to load WASM module: ' + (e.message || e);
                statusEl.textContent = 'Failed to load';
                statusEl.className = 'error';
                errorEl.textContent = errMsg;
                console.error('WASM load error:', e);
                console.error('Full error:', e.stack);

                window.analyzeNetwork = function() {
                    alert('WASM module failed to load. Please refresh the page.');
                };
            }
        })();
        // End DOMContentLoaded wrapper
        });
    </script>

    <!-- Hidden elements for recording -->
    <div id="hiddenVideos" style="position:absolute;opacity:0;pointer-events:none;width:1px;height:1px;">
        <video id="cameraVideo" autoplay muted playsinline></video>
        <video id="screenVideo" autoplay muted playsinline></video>
        <canvas id="recordingCanvas"></canvas>
    </div>
</body>
</html>
