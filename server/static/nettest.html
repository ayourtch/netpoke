<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Network Measurement Client</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #status { font-weight: bold; margin: 20px 0; }
        #metrics { margin-top: 20px; }
        .dual-stack-container { display: flex; gap: 20px; }
        .stack-column { flex: 1; }
        table { border-collapse: collapse; margin-top: 10px; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #4CAF50; color: white; }
        td:first-child { text-align: left; }
        .ipv4 th { background-color: #2196F3; }
        .ipv6 th { background-color: #FF9800; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        button:hover { background-color: #ddd; }
        .running { color: green; }
        .error { color: red; }
        #chart-container { margin-top: 40px; }
        #metrics-chart { max-height: 600px; }
        .chart-controls { margin: 20px 0; }
        .chart-controls button { margin-right: 10px; }
        #wake-lock-status { 
            display: inline-block;
            margin-left: 15px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            background-color: #f0f0f0;
            color: #666;
        }
        #wake-lock-status.active { 
            background-color: #4CAF50;
            color: white;
        }
        #wake-lock-status.unsupported { 
            background-color: #ff9800;
            color: white;
        }
    </style>
</head>
<body>
    <h1>Network Measurement Client</h1>
    <div style="margin-bottom: 15px;">
        <label for="conn-count" style="font-weight: bold; margin-right: 10px;">Connections per Address Family (ECMP):</label>
        <select id="conn-count" style="padding: 5px; font-size: 14px;">
            <option value="1" selected>1 connection</option>
            <option value="2">2 connections</option>
            <option value="4">4 connections</option>
            <option value="8">8 connections</option>
            <option value="16">16 connections</option>
        </select>
    </div>
    <button id="analyze-network-btn" onclick="analyzeNetwork()">Analyze Network</button>
    <span id="wake-lock-status">Wake Lock: Checking...</span>
    <div id="status">Loading WASM module...</div>
    <div id="ayxx"></div>
    <div id="error" style="color: red; font-weight: bold; margin: 10px 0;"></div>
    <div id="metrics">
        <h2>Dual-Stack Network Measurement</h2>
        <div id="metrics-tables-container">
            <!-- Dynamic connection tables will be inserted here by JavaScript -->
            <div class="dual-stack-container" id="default-metrics">
                <div class="stack-column">
                    <h3>IPv4 Connection</h3>
                    <table class="ipv4">
                        <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                        <tr><td>Throughput</td><td id="ipv4-s2c-tp-1">-</td><td id="ipv4-s2c-tp-10">-</td><td id="ipv4-s2c-tp-60">-</td></tr>
                        <tr><td>Delay (ms)</td><td id="ipv4-s2c-delay-1">-</td><td id="ipv4-s2c-delay-10">-</td><td id="ipv4-s2c-delay-60">-</td></tr>
                        <tr><td>Jitter (ms)</td><td id="ipv4-s2c-jitter-1">-</td><td id="ipv4-s2c-jitter-10">-</td><td id="ipv4-s2c-jitter-60">-</td></tr>
                        <tr><td>Loss Rate</td><td id="ipv4-s2c-loss-1">-</td><td id="ipv4-s2c-loss-10">-</td><td id="ipv4-s2c-loss-60">-</td></tr>
                        <tr><td>Reordering</td><td id="ipv4-s2c-reorder-1">-</td><td id="ipv4-s2c-reorder-10">-</td><td id="ipv4-s2c-reorder-60">-</td></tr>
                    </table>
                </div>
                <div class="stack-column">
                    <h3>IPv6 Connection</h3>
                    <table class="ipv6">
                        <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                        <tr><td>Throughput</td><td id="ipv6-s2c-tp-1">-</td><td id="ipv6-s2c-tp-10">-</td><td id="ipv6-s2c-tp-60">-</td></tr>
                        <tr><td>Delay (ms)</td><td id="ipv6-s2c-delay-1">-</td><td id="ipv6-s2c-delay-10">-</td><td id="ipv6-s2c-delay-60">-</td></tr>
                        <tr><td>Jitter (ms)</td><td id="ipv6-s2c-jitter-1">-</td><td id="ipv6-s2c-jitter-10">-</td><td id="ipv6-s2c-jitter-60">-</td></tr>
                        <tr><td>Loss Rate</td><td id="ipv6-s2c-loss-1">-</td><td id="ipv6-s2c-loss-10">-</td><td id="ipv6-s2c-loss-60">-</td></tr>
                        <tr><td>Reordering</td><td id="ipv6-s2c-reorder-1">-</td><td id="ipv6-s2c-reorder-10">-</td><td id="ipv6-s2c-reorder-60">-</td></tr>
                    </table>
                </div>
            </div>
        </div>

        <h2>Client â†’ Server Metrics</h2>
        <p><em>C2S metrics are measured by the server and visible on the <a href="/static/dashboard.html">dashboard</a>.</em></p>
    </div>

    <div id="traceroute-visualization" style="margin-top: 20px;">
        <h2>Traceroute Path Visualization</h2>
        <p style="font-size: 12px; color: #666; margin-bottom: 10px;"><em>Visual representation of network path. Each column represents a hop, nodes show router addresses. Hover for details.</em></p>
        <div id="traceroute-graph" style="border: 1px solid #ddd; background-color: #fafafa; padding: 20px; min-height: 300px; overflow-x: auto;">
            <div style="text-align: center; color: #999; padding: 40px;">No traceroute data available. Click "Analyze Path" to start.</div>
        </div>
    </div>

    <div id="server-messages-container" style="margin-top: 20px;">
        <h2>Server Messages (Traceroute Log)</h2>
        <p style="font-size: 12px; color: #666; margin-bottom: 5px;"><em>Raw traceroute messages. Messages are prefixed with [conn_id] to identify which connection each hop belongs to.</em></p>
        <textarea id="server-messages" readonly style="width: 100%; height: 150px; font-family: monospace; font-size: 12px; padding: 10px; border: 1px solid #ddd; background-color: #f5f5f5;"></textarea>
    </div>

    <div id="chart-container">
        <h2>Live Metrics Graph</h2>
        <div class="chart-controls">
            <button onclick="toggleMetric('throughput')">Toggle Throughput</button>
            <button onclick="toggleMetric('delay')">Toggle Delay</button>
            <button onclick="toggleMetric('jitter')">Toggle Jitter</button>
            <button onclick="toggleMetric('loss')">Toggle Loss</button>
            <button onclick="toggleMetric('reordering')">Toggle Reordering</button>
            <button onclick="resetZoom()">Reset Zoom</button>
        </div>
        <canvas id="metrics-chart"></canvas>
    </div>

    <script src="/static/lib/chart.umd.js"></script>
    <script src="/static/lib/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="/static/lib/chartjs-plugin-zoom.min.js"></script>
    <script>
        // Global variables for chart management
        let metricsChart = null;
        let chartData = {
            timestamps: [], // Used for data management and calculating relative time
            ipv4: {
                throughput_1s: [], throughput_10s: [], throughput_60s: [],
                delay_1s: [], delay_10s: [], delay_60s: [],
                jitter_1s: [], jitter_10s: [], jitter_60s: [],
                loss_1s: [], loss_10s: [], loss_60s: [],
                reorder_1s: [], reorder_10s: [], reorder_60s: []
            },
            ipv6: {
                throughput_1s: [], throughput_10s: [], throughput_60s: [],
                delay_1s: [], delay_10s: [], delay_60s: [],
                jitter_1s: [], jitter_10s: [], jitter_60s: [],
                loss_1s: [], loss_10s: [], loss_60s: [],
                reorder_1s: [], reorder_10s: [], reorder_60s: []
            }
        };
        const MAX_DATA_POINTS = 300; // 5 minutes at 1 second intervals
        let lastChartUpdate = 0;
        const CHART_UPDATE_INTERVAL = 1000; // Update chart every 1 second

        // Visible metric groups
        let visibleMetrics = {
            throughput: true,
            delay: true,
            jitter: true,
            loss: true,
            reordering: true
        };

        function initChart() {
            const ctx = document.getElementById('metrics-chart').getContext('2d');
            
            metricsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'time',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            time: {
                                displayFormats: {
                                    millisecond: 'HH:mm:ss.SSS',
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm:ss',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'yyyy-MM-dd HH:mm:ss.SSS'
                            },
                            ticks: {
                                source: 'data',
                                maxRotation: 45,
                                autoSkip: true
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Value'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 20,
                                font: {
                                    size: 10
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    if (context.length > 0) {
                                        const timestamp = context[0].parsed.x;
                                        const date = new Date(timestamp);
                                        return date.toISOString().replace('T', ' ').replace('Z', '');
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    animation: false
                }
            });
            
            updateChartDatasets();
        }

        function updateChartDatasets() {
            const datasets = [];
            const colors = {
                ipv4: { r: 33, g: 150, b: 243 },    // Blue
                ipv6: { r: 255, g: 152, b: 0 }       // Orange
            };

            const metricConfigs = [
                { key: 'throughput', name: 'Throughput', unit: 'KB/s', visible: visibleMetrics.throughput },
                { key: 'delay', name: 'Delay', unit: 'ms', visible: visibleMetrics.delay },
                { key: 'jitter', name: 'Jitter', unit: 'ms', visible: visibleMetrics.jitter },
                { key: 'loss', name: 'Loss', unit: '%', visible: visibleMetrics.loss },
                { key: 'reorder', name: 'Reorder', unit: '%', visible: visibleMetrics.reordering }
            ];

            const windows = [
                { key: '1s', dash: [], width: 2 }
            ];

            for (const metric of metricConfigs) {
                if (!metric.visible) continue;

                for (const window of windows) {
                    for (const [ipVersion, color] of Object.entries(colors)) {
                        const dataKey = `${metric.key}_${window.key}`;
                        const data = chartData[ipVersion][dataKey] || [];
                        
                        datasets.push({
                            label: `${ipVersion.toUpperCase()} ${metric.name} ${window.key} (${metric.unit})`,
                            data: data,
                            borderColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`,
                            backgroundColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`,
                            borderWidth: window.width,
                            borderDash: window.dash,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHitRadius: 5,
                            spanGaps: false
                        });
                    }
                }
            }

            if (metricsChart) {
                metricsChart.data.datasets = datasets;
                metricsChart.update('none');
            }
        }

        function toggleMetric(metricType) {
            visibleMetrics[metricType] = !visibleMetrics[metricType];
            updateChartDatasets();
        }

        function resetZoom() {
            if (metricsChart) {
                metricsChart.resetZoom();
            }
        }

        function addMetricsData(ipv4Metrics, ipv6Metrics) {
            const now = Date.now();
            
            // Only update chart every second to avoid performance issues
            if (now - lastChartUpdate < CHART_UPDATE_INTERVAL) {
                return;
            }
            lastChartUpdate = now;

            // Use milliseconds timestamp for Chart.js time scale
            chartData.timestamps.push(now);

            // Helper to convert bytes/sec to KB/sec
            const bytesToKB = (bytes) => bytes / 1024;

            // Add IPv4 metrics
            chartData.ipv4.throughput_1s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[0]) });
            chartData.ipv4.throughput_10s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[1]) });
            chartData.ipv4.throughput_60s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[2]) });
            chartData.ipv4.delay_1s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[0] });
            chartData.ipv4.delay_10s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[1] });
            chartData.ipv4.delay_60s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[2] });
            chartData.ipv4.jitter_1s.push({ x: now, y: ipv4Metrics.s2c_jitter[0] });
            chartData.ipv4.jitter_10s.push({ x: now, y: ipv4Metrics.s2c_jitter[1] });
            chartData.ipv4.jitter_60s.push({ x: now, y: ipv4Metrics.s2c_jitter[2] });
            chartData.ipv4.loss_1s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[0] });
            chartData.ipv4.loss_10s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[1] });
            chartData.ipv4.loss_60s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[2] });
            chartData.ipv4.reorder_1s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[0] });
            chartData.ipv4.reorder_10s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[1] });
            chartData.ipv4.reorder_60s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[2] });

            // Add IPv6 metrics
            chartData.ipv6.throughput_1s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[0]) });
            chartData.ipv6.throughput_10s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[1]) });
            chartData.ipv6.throughput_60s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[2]) });
            chartData.ipv6.delay_1s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[0] });
            chartData.ipv6.delay_10s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[1] });
            chartData.ipv6.delay_60s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[2] });
            chartData.ipv6.jitter_1s.push({ x: now, y: ipv6Metrics.s2c_jitter[0] });
            chartData.ipv6.jitter_10s.push({ x: now, y: ipv6Metrics.s2c_jitter[1] });
            chartData.ipv6.jitter_60s.push({ x: now, y: ipv6Metrics.s2c_jitter[2] });
            chartData.ipv6.loss_1s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[0] });
            chartData.ipv6.loss_10s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[1] });
            chartData.ipv6.loss_60s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[2] });
            chartData.ipv6.reorder_1s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[0] });
            chartData.ipv6.reorder_10s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[1] });
            chartData.ipv6.reorder_60s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[2] });

            // Limit data points to prevent memory issues
            if (chartData.timestamps.length > MAX_DATA_POINTS) {
                chartData.timestamps.shift();
                for (const ipVersion of ['ipv4', 'ipv6']) {
                    for (const key in chartData[ipVersion]) {
                        chartData[ipVersion][key].shift();
                    }
                }
            }

            // Update chart directly without transformation
            if (metricsChart) {
                updateChartDatasets();
                metricsChart.update('none');
            }
        }

        // Initialize chart when page loads
        window.addEventListener('load', () => {
            initChart();
        });

        // Make addMetricsData globally available
        window.addMetricsData = addMetricsData;
        
        // Traceroute visualization data structure
        let tracerouteData = {
            // Map of connection_id -> array of hop objects
            // Each hop object: { hop: number, ip_address: string|null, rtt_ms: number, message: string }
            connections: {}
        };
        
        // Function to add traceroute hop data
        function addTracerouteHop(hopData) {
            const connId = hopData.conn_id || 'default';
            if (!tracerouteData.connections[connId]) {
                tracerouteData.connections[connId] = [];
            }
            
            // Check if hop already exists (update) or add new
            const existingHopIndex = tracerouteData.connections[connId].findIndex(h => h.hop === hopData.hop);
            if (existingHopIndex >= 0 && hopData.ip_address) {
                // Update existing hop with new data (only if we have an IP address)
                tracerouteData.connections[connId][existingHopIndex] = hopData;
            } else if (existingHopIndex < 0) {
                // Add new hop
                tracerouteData.connections[connId].push(hopData);
            }
            
            // Re-render the visualization
            renderTracerouteGraph();
        }
        
        // Function to clear traceroute data
        function clearTracerouteData() {
            tracerouteData.connections = {};
            renderTracerouteGraph();
        }
        
        // Function to render the traceroute graph
        function renderTracerouteGraph() {
            const graphContainer = document.getElementById('traceroute-graph');
            if (!graphContainer) return;
            
            const connections = tracerouteData.connections;
            const connIds = Object.keys(connections);
            
            if (connIds.length === 0) {
                graphContainer.innerHTML = '<div style="text-align: center; color: #999; padding: 40px;">No traceroute data available. Click "Analyze Path" to start.</div>';
                return;
            }
            
            // Find max hop number across all connections
            let maxHop = 0;
            connIds.forEach(connId => {
                connections[connId].forEach(hop => {
                    if (hop.hop > maxHop) maxHop = hop.hop;
                });
            });
            
            // Build HTML for the graph
            let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
            
            // For each hop number, create a column
            for (let hopNum = 1; hopNum <= maxHop; hopNum++) {
                html += '<div style="display: flex; align-items: center; gap: 10px; padding: 5px 0;">';
                html += `<div style="min-width: 60px; font-weight: bold; color: #555;">Hop ${hopNum}:</div>`;
                html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; flex: 1;">';
                
                // Find all nodes at this hop across all connections
                const nodesAtHop = [];
                connIds.forEach(connId => {
                    const hop = connections[connId].find(h => h.hop === hopNum);
                    if (hop) {
                        nodesAtHop.push({ connId, hop });
                    }
                });
                
                if (nodesAtHop.length === 0) {
                    html += '<div style="color: #999; font-style: italic;">No response</div>';
                } else {
                    // Group nodes by IP address
                    const nodesByIp = {};
                    nodesAtHop.forEach(({ connId, hop }) => {
                        const ip = hop.ip_address || 'unknown';
                        if (!nodesByIp[ip]) {
                            nodesByIp[ip] = [];
                        }
                        nodesByIp[ip].push({ connId, hop });
                    });
                    
                    // Render each unique IP as a node
                    Object.keys(nodesByIp).forEach(ip => {
                        const nodes = nodesByIp[ip];
                        const connCount = nodes.length;
                        const avgRtt = nodes.reduce((sum, n) => sum + n.hop.rtt_ms, 0) / connCount;
                        
                        // Create tooltip with all connections that hit this node
                        const tooltipLines = nodes.map(({ connId, hop }) => {
                            const shortId = connId.substring(0, 8);
                            return `[${shortId}] RTT: ${hop.rtt_ms.toFixed(2)}ms`;
                        });
                        const tooltip = `Hop ${hopNum}\\n${ip}\\n\\nConnections (${connCount}):${tooltipLines.map(l => '\\n' + l).join('')}`;
                        
                        // Node styling - color based on number of connections
                        const nodeColor = connCount === connIds.length ? '#4CAF50' : '#FF9800';
                        const borderStyle = connCount === connIds.length ? 'solid' : 'dashed';
                        
                        html += `<div style="
                            position: relative;
                            background: ${nodeColor};
                            color: white;
                            padding: 8px 12px;
                            border-radius: 6px;
                            border: 2px ${borderStyle} ${nodeColor};
                            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                            cursor: help;
                            font-size: 12px;
                            white-space: nowrap;
                            transition: transform 0.2s, box-shadow 0.2s;
                        " title="${tooltip}" onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.3)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.2)';">
                            <div style="font-weight: bold;">${ip}</div>
                            <div style="font-size: 10px; opacity: 0.9;">${avgRtt.toFixed(1)}ms avg</div>
                            <div style="font-size: 9px; opacity: 0.8;">${connCount}/${connIds.length} conn</div>
                        </div>`;
                    });
                }
                
                html += '</div></div>';
            }
            
            html += '</div>';
            
            // Add legend
            html += `<div style="margin-top: 20px; padding: 10px; background: #f9f9f9; border-radius: 4px; font-size: 12px;">
                <strong>Legend:</strong>
                <span style="margin-left: 15px;">
                    <span style="display: inline-block; width: 12px; height: 12px; background: #4CAF50; border: 2px solid #4CAF50; border-radius: 2px; margin-right: 5px;"></span>
                    All connections pass through (solid border)
                </span>
                <span style="margin-left: 15px;">
                    <span style="display: inline-block; width: 12px; height: 12px; background: #FF9800; border: 2px dashed #FF9800; border-radius: 2px; margin-right: 5px;"></span>
                    Partial connections (dashed border)
                </span>
            </div>`;
            
            graphContainer.innerHTML = html;
        }
        
        // Make traceroute functions globally available
        window.addTracerouteHop = addTracerouteHop;
        window.clearTracerouteData = clearTracerouteData;
        
        // Function to generate metrics tables for multiple connections
        function generateMultiConnectionTables(connCount) {
            const container = document.getElementById('metrics-tables-container');
            if (!container) return;
            
            // If only 1 connection, use the default tables
            if (connCount <= 1) {
                document.getElementById('default-metrics').style.display = 'flex';
                return;
            }
            
            // Hide default metrics and create dynamic tables
            document.getElementById('default-metrics').style.display = 'none';
            
            // Clear any existing dynamic tables
            const existingDynamic = container.querySelectorAll('.dynamic-metrics');
            existingDynamic.forEach(el => el.remove());
            
            // Create a table for each connection pair (IPv4 + IPv6)
            for (let i = 0; i < connCount; i++) {
                const connDiv = document.createElement('div');
                connDiv.className = 'dual-stack-container dynamic-metrics';
                connDiv.style.marginBottom = '20px';
                connDiv.innerHTML = `
                    <div class="stack-column">
                        <h3>IPv4 Connection #${i + 1}</h3>
                        <table class="ipv4">
                            <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                            <tr><td>Throughput</td><td id="ipv4-${i}-s2c-tp-1">-</td><td id="ipv4-${i}-s2c-tp-10">-</td><td id="ipv4-${i}-s2c-tp-60">-</td></tr>
                            <tr><td>Delay (ms)</td><td id="ipv4-${i}-s2c-delay-1">-</td><td id="ipv4-${i}-s2c-delay-10">-</td><td id="ipv4-${i}-s2c-delay-60">-</td></tr>
                            <tr><td>Jitter (ms)</td><td id="ipv4-${i}-s2c-jitter-1">-</td><td id="ipv4-${i}-s2c-jitter-10">-</td><td id="ipv4-${i}-s2c-jitter-60">-</td></tr>
                            <tr><td>Loss Rate</td><td id="ipv4-${i}-s2c-loss-1">-</td><td id="ipv4-${i}-s2c-loss-10">-</td><td id="ipv4-${i}-s2c-loss-60">-</td></tr>
                            <tr><td>Reordering</td><td id="ipv4-${i}-s2c-reorder-1">-</td><td id="ipv4-${i}-s2c-reorder-10">-</td><td id="ipv4-${i}-s2c-reorder-60">-</td></tr>
                        </table>
                    </div>
                    <div class="stack-column">
                        <h3>IPv6 Connection #${i + 1}</h3>
                        <table class="ipv6">
                            <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                            <tr><td>Throughput</td><td id="ipv6-${i}-s2c-tp-1">-</td><td id="ipv6-${i}-s2c-tp-10">-</td><td id="ipv6-${i}-s2c-tp-60">-</td></tr>
                            <tr><td>Delay (ms)</td><td id="ipv6-${i}-s2c-delay-1">-</td><td id="ipv6-${i}-s2c-delay-10">-</td><td id="ipv6-${i}-s2c-delay-60">-</td></tr>
                            <tr><td>Jitter (ms)</td><td id="ipv6-${i}-s2c-jitter-1">-</td><td id="ipv6-${i}-s2c-jitter-10">-</td><td id="ipv6-${i}-s2c-jitter-60">-</td></tr>
                            <tr><td>Loss Rate</td><td id="ipv6-${i}-s2c-loss-1">-</td><td id="ipv6-${i}-s2c-loss-10">-</td><td id="ipv6-${i}-s2c-loss-60">-</td></tr>
                            <tr><td>Reordering</td><td id="ipv6-${i}-s2c-reorder-1">-</td><td id="ipv6-${i}-s2c-reorder-10">-</td><td id="ipv6-${i}-s2c-reorder-60">-</td></tr>
                        </table>
                    </div>
                `;
                container.appendChild(connDiv);
            }
        }
        
        // Function to update metrics for a specific connection
        function updateConnectionMetrics(ipVersion, connIndex, metrics) {
            const prefix = `${ipVersion}-${connIndex}-s2c`;
            const setBytesToKB = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = (value / 1024).toFixed(2) + ' KB/s';
            };
            const setMs = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value.toFixed(2);
            };
            const setPercent = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value.toFixed(2) + '%';
            };
            
            setBytesToKB(`${prefix}-tp-1`, metrics.s2c_throughput[0]);
            setBytesToKB(`${prefix}-tp-10`, metrics.s2c_throughput[1]);
            setBytesToKB(`${prefix}-tp-60`, metrics.s2c_throughput[2]);
            setMs(`${prefix}-delay-1`, metrics.s2c_delay_avg[0]);
            setMs(`${prefix}-delay-10`, metrics.s2c_delay_avg[1]);
            setMs(`${prefix}-delay-60`, metrics.s2c_delay_avg[2]);
            setMs(`${prefix}-jitter-1`, metrics.s2c_jitter[0]);
            setMs(`${prefix}-jitter-10`, metrics.s2c_jitter[1]);
            setMs(`${prefix}-jitter-60`, metrics.s2c_jitter[2]);
            setPercent(`${prefix}-loss-1`, metrics.s2c_loss_rate[0]);
            setPercent(`${prefix}-loss-10`, metrics.s2c_loss_rate[1]);
            setPercent(`${prefix}-loss-60`, metrics.s2c_loss_rate[2]);
            setPercent(`${prefix}-reorder-1`, metrics.s2c_reorder_rate[0]);
            setPercent(`${prefix}-reorder-10`, metrics.s2c_reorder_rate[1]);
            setPercent(`${prefix}-reorder-60`, metrics.s2c_reorder_rate[2]);
        }
        
        // Make functions globally available
        window.generateMultiConnectionTables = generateMultiConnectionTables;
        window.updateConnectionMetrics = updateConnectionMetrics;
    </script>
    <script type="module">
        const errorEl = document.getElementById('error');
        const statusEl = document.getElementById('status');
        const analyzeNetworkBtn = document.getElementById('analyze-network-btn');
        const wakeLockStatusEl = document.getElementById('wake-lock-status');

        // Check if Wake Lock API is supported
        function checkWakeLockSupport() {
            if ('wakeLock' in navigator) {
                wakeLockStatusEl.textContent = 'ðŸ”“ Wake Lock: Ready';
                wakeLockStatusEl.className = '';
            } else {
                wakeLockStatusEl.textContent = 'âš ï¸ Wake Lock: Not Supported';
                wakeLockStatusEl.className = 'unsupported';
            }
        }

        // Call on page load
        checkWakeLockSupport();

        // Wrap in async IIFE for better Safari compatibility
        (async () => {
            try {
                // Cache-busting timestamp
                const cacheBuster = Date.now();

                // Import the JS wrapper (without cache-busting query param for Safari compatibility)
                const module = await import('/public/pkg/wifi_verify_client.js');
                const { default: init, start_measurement, start_measurement_with_count, analyze_path, analyze_path_with_count, analyze_network, analyze_network_with_count } = module;

                // Initialize WASM with explicit path and cache-busting
                // Pass the .wasm file path to init() for Safari compatibility
                await init(`/public/pkg/wifi_verify_client_bg.wasm?v=${cacheBuster}`);
                console.log('WASM module loaded successfully');
                statusEl.textContent = 'Ready';
                statusEl.className = '';
                
                // Get connection count from dropdown
                const getConnCount = () => {
                    const select = document.getElementById('conn-count');
                    return parseInt(select.value, 10) || 1;
                };

                window.analyzeNetwork = async function() {
                    statusEl.textContent = 'Starting network analysis...';
                    statusEl.className = '';
                    analyzeNetworkBtn.disabled = true;
                    errorEl.textContent = '';
                    
                    // Clear the server messages textarea
                    const serverMessagesEl = document.getElementById('server-messages');
                    if (serverMessagesEl) {
                        serverMessagesEl.value = '';
                    }
                    
                    // Clear traceroute visualization
                    if (window.clearTracerouteData) {
                        window.clearTracerouteData();
                    }
                    
                    const connCount = getConnCount();
                    console.log(`Starting network analysis with ${connCount} connections per address family`);
                    
                    // Generate dynamic tables for multi-connection display
                    if (window.generateMultiConnectionTables) {
                        window.generateMultiConnectionTables(connCount);
                    }

                    try {
                        // Update status to show phase 1 (traceroute)
                        statusEl.textContent = `Phase 1: Analyzing network paths (traceroute) with ${connCount} connection(s)...`;
                        statusEl.className = 'running';
                        
                        // Update wake lock status
                        if ('wakeLock' in navigator) {
                            wakeLockStatusEl.textContent = 'ðŸ”’ Wake Lock: Active';
                            wakeLockStatusEl.className = 'active';
                        }
                        
                        // Start the combined analysis
                        await analyze_network_with_count(connCount);
                        
                        // Update UI to show measurements are now running
                        statusEl.textContent = `Phase 2: Running network measurements with ${connCount} connection(s)...`;
                        statusEl.className = 'running';
                        
                    } catch (e) {
                        const errMsg = 'Network analysis error: ' + (e.message || e);
                        statusEl.textContent = 'Error';
                        statusEl.className = 'error';
                        errorEl.textContent = errMsg;
                        analyzeNetworkBtn.disabled = false;
                        console.error('Network analysis error:', e);
                        
                        // Update wake lock status
                        if ('wakeLock' in navigator) {
                            wakeLockStatusEl.textContent = 'ðŸ”“ Wake Lock: Ready';
                            wakeLockStatusEl.className = '';
                        }
                    }
                };
            } catch (e) {
                const errMsg = 'Failed to load WASM module: ' + (e.message || e);
                statusEl.textContent = 'Failed to load';
                statusEl.className = 'error';
                errorEl.textContent = errMsg;
                console.error('WASM load error:', e);
                console.error('Full error:', e.stack);

                window.analyzeNetwork = function() {
                    alert('WASM module failed to load. Please refresh the page.');
                };
            }
        })();
    </script>
</body>
</html>
