<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Network Measurement Client</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #status { font-weight: bold; margin: 20px 0; }
        #metrics { margin-top: 20px; }
        .dual-stack-container { display: flex; gap: 20px; }
        .stack-column { flex: 1; }
        table { border-collapse: collapse; margin-top: 10px; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #4CAF50; color: white; }
        td:first-child { text-align: left; }
        .ipv4 th { background-color: #2196F3; }
        .ipv6 th { background-color: #FF9800; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        button:hover { background-color: #ddd; }
        button:disabled { 
            background-color: #ccc; 
            color: #666; 
            cursor: not-allowed; 
            opacity: 0.6;
        }
        #stop-testing-btn { 
            background-color: #f44336; 
            color: white; 
            margin-left: 10px;
        }
        #stop-testing-btn:hover:not(:disabled) { 
            background-color: #d32f2f; 
        }
        #stop-testing-btn:disabled {
            background-color: #ccc;
            color: #666;
        }
        .running { color: green; }
        .error { color: red; }
        #chart-container { margin-top: 40px; }
        #metrics-chart { max-height: 600px; }
        .chart-controls { margin: 20px 0; }
        .chart-controls button { margin-right: 10px; }
        #wake-lock-status { 
            display: inline-block;
            margin-left: 15px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            background-color: #f0f0f0;
            color: #666;
        }
        #wake-lock-status.active { 
            background-color: #4CAF50;
            color: white;
        }
        #wake-lock-status.unsupported { 
            background-color: #ff9800;
            color: white;
        }
    </style>
</head>
<body>
    <h1>Network Measurement Client</h1>
    <div style="margin-bottom: 15px;">
        <label for="conn-count" style="font-weight: bold; margin-right: 10px;">Connections per Address Family (ECMP):</label>
        <select id="conn-count" style="padding: 5px; font-size: 14px;">
            <option value="1" selected>1 connection</option>
            <option value="2">2 connections</option>
            <option value="4">4 connections</option>
            <option value="8">8 connections</option>
            <option value="16">16 connections</option>
        </select>
    </div>
    <button id="analyze-network-btn" onclick="analyzeNetwork()">Analyze Network</button>
    <button id="stop-testing-btn" onclick="stopTesting()" disabled>Stop Testing</button>
    <span id="wake-lock-status">Wake Lock: Checking...</span>
    <div id="status">Loading WASM module...</div>
    <div id="ayxx"></div>
    <div id="error" style="color: red; font-weight: bold; margin: 10px 0;"></div>
    <div id="metrics">
        <h2>Dual-Stack Network Measurement</h2>
        <div id="metrics-tables-container">
            <!-- Dynamic connection tables will be inserted here by JavaScript -->
            <div class="dual-stack-container" id="default-metrics">
                <div class="stack-column">
                    <h3>IPv4 Connection <span id="ipv4-0-conn-id" style="font-size: 0.8em; color: #666;"></span></h3>
                    <table class="ipv4">
                        <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                        <tr><td>Throughput</td><td id="ipv4-s2c-tp-1">-</td><td id="ipv4-s2c-tp-10">-</td><td id="ipv4-s2c-tp-60">-</td></tr>
                        <tr><td>Delay (ms)</td><td id="ipv4-s2c-delay-1">-</td><td id="ipv4-s2c-delay-10">-</td><td id="ipv4-s2c-delay-60">-</td></tr>
                        <tr><td>Jitter (ms)</td><td id="ipv4-s2c-jitter-1">-</td><td id="ipv4-s2c-jitter-10">-</td><td id="ipv4-s2c-jitter-60">-</td></tr>
                        <tr><td>Loss Rate</td><td id="ipv4-s2c-loss-1">-</td><td id="ipv4-s2c-loss-10">-</td><td id="ipv4-s2c-loss-60">-</td></tr>
                        <tr><td>Reordering</td><td id="ipv4-s2c-reorder-1">-</td><td id="ipv4-s2c-reorder-10">-</td><td id="ipv4-s2c-reorder-60">-</td></tr>
                    </table>
                </div>
                <div class="stack-column">
                    <h3>IPv6 Connection <span id="ipv6-0-conn-id" style="font-size: 0.8em; color: #666;"></span></h3>
                    <table class="ipv6">
                        <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                        <tr><td>Throughput</td><td id="ipv6-s2c-tp-1">-</td><td id="ipv6-s2c-tp-10">-</td><td id="ipv6-s2c-tp-60">-</td></tr>
                        <tr><td>Delay (ms)</td><td id="ipv6-s2c-delay-1">-</td><td id="ipv6-s2c-delay-10">-</td><td id="ipv6-s2c-delay-60">-</td></tr>
                        <tr><td>Jitter (ms)</td><td id="ipv6-s2c-jitter-1">-</td><td id="ipv6-s2c-jitter-10">-</td><td id="ipv6-s2c-jitter-60">-</td></tr>
                        <tr><td>Loss Rate</td><td id="ipv6-s2c-loss-1">-</td><td id="ipv6-s2c-loss-10">-</td><td id="ipv6-s2c-loss-60">-</td></tr>
                        <tr><td>Reordering</td><td id="ipv6-s2c-reorder-1">-</td><td id="ipv6-s2c-reorder-10">-</td><td id="ipv6-s2c-reorder-60">-</td></tr>
                    </table>
                </div>
            </div>
        </div>

        <h2>Client â†’ Server Metrics</h2>
        <p><em>C2S metrics are measured by the server and visible on the <a href="/static/dashboard.html">dashboard</a>.</em></p>
    </div>

    <div id="peer-connections-container" style="margin-top: 20px;">
        <h2>Peer Connections</h2>
        <p style="font-size: 12px; color: #666; margin-bottom: 10px;"><em>Active peer connections with their connection IDs (matching traceroute data) and address information.</em></p>
        <div id="peer-connections-list" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 15px;">
            <div style="text-align: center; color: #999; padding: 20px; border: 1px dashed #ccc; border-radius: 4px;">No active connections. Click "Analyze Network" to start.</div>
        </div>
    </div>

    <div id="traceroute-visualization" style="margin-top: 20px;">
        <h2>Traceroute Path Visualization</h2>
        <p style="font-size: 12px; color: #666; margin-bottom: 10px;"><em>Visual representation of network path. Each column represents a hop, nodes show router addresses. Hover for details.</em></p>
        
        <div class="dual-stack-container">
            <div class="stack-column">
                <h3 style="color: #2196F3;">IPv4 Path</h3>
                <div id="traceroute-graph-ipv4" style="border: 1px solid #2196F3; background-color: #fafafa; padding: 20px; min-height: 200px; overflow-x: auto;">
                    <div style="text-align: center; color: #999; padding: 40px;">No IPv4 traceroute data available.</div>
                </div>
            </div>
            <div class="stack-column">
                <h3 style="color: #FF9800;">IPv6 Path</h3>
                <div id="traceroute-graph-ipv6" style="border: 1px solid #FF9800; background-color: #fafafa; padding: 20px; min-height: 200px; overflow-x: auto;">
                    <div style="text-align: center; color: #999; padding: 40px;">No IPv6 traceroute data available.</div>
                </div>
            </div>
        </div>
    </div>

    <div id="server-messages-container" style="margin-top: 20px;">
        <h2>Server Messages (Traceroute Log)</h2>
        <p style="font-size: 12px; color: #666; margin-bottom: 5px;"><em>Raw traceroute messages. Messages are prefixed with [conn_id] to identify which connection each hop belongs to.</em></p>
        <textarea id="server-messages" readonly style="width: 100%; height: 150px; font-family: monospace; font-size: 12px; padding: 10px; border: 1px solid #ddd; background-color: #f5f5f5;"></textarea>
    </div>

    <div id="packet-capture-container" style="margin-top: 20px;">
        <h2>Packet Capture & Tracing</h2>
        <p style="font-size: 12px; color: #666; margin-bottom: 10px;">
            <em>Download captured network traffic (PCAP) or server logs (tracing buffer) for analysis.</em>
        </p>
        <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
            <div style="display: flex; flex-direction: column; gap: 5px;">
                <a id="download-pcap-btn" href="/api/capture/download" 
                   style="display: inline-block; padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none; border-radius: 4px; font-weight: bold; text-align: center;">
                    ðŸ“¥ Download PCAP
                </a>
                <span id="capture-status" style="color: #666; font-size: 14px;">Checking capture status...</span>
            </div>
            <div style="display: flex; flex-direction: column; gap: 5px;">
                <a id="download-tracing-btn" href="/api/tracing/download" 
                   style="display: inline-block; padding: 10px 20px; background-color: #2196F3; color: white; text-decoration: none; border-radius: 4px; font-weight: bold; text-align: center;">
                    ðŸ“‹ Download Tracing Log
                </a>
                <span id="tracing-status" style="color: #666; font-size: 14px;">Checking tracing status...</span>
            </div>
        </div>
    </div>

    <div id="chart-container">
        <h2>Live Metrics Graph</h2>
        <div class="chart-controls">
            <button onclick="toggleMetric('throughput')">Toggle Throughput</button>
            <button onclick="toggleMetric('delay')">Toggle Delay</button>
            <button onclick="toggleMetric('jitter')">Toggle Jitter</button>
            <button onclick="toggleMetric('loss')">Toggle Loss</button>
            <button onclick="toggleMetric('reordering')">Toggle Reordering</button>
            <button onclick="resetZoom()">Reset Zoom</button>
        </div>
        <canvas id="metrics-chart"></canvas>
    </div>

    <script src="/static/lib/chart.umd.js"></script>
    <script src="/static/lib/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="/static/lib/chartjs-plugin-zoom.min.js"></script>
    <script>
        // Global variables for chart management
        let metricsChart = null;
        let chartData = {
            timestamps: [], // Used for data management and calculating relative time
            ipv4: {
                throughput_1s: [], throughput_10s: [], throughput_60s: [],
                delay_1s: [], delay_10s: [], delay_60s: [],
                jitter_1s: [], jitter_10s: [], jitter_60s: [],
                loss_1s: [], loss_10s: [], loss_60s: [],
                reorder_1s: [], reorder_10s: [], reorder_60s: []
            },
            ipv6: {
                throughput_1s: [], throughput_10s: [], throughput_60s: [],
                delay_1s: [], delay_10s: [], delay_60s: [],
                jitter_1s: [], jitter_10s: [], jitter_60s: [],
                loss_1s: [], loss_10s: [], loss_60s: [],
                reorder_1s: [], reorder_10s: [], reorder_60s: []
            }
        };
        const MAX_DATA_POINTS = 300; // 5 minutes at 1 second intervals
        let lastChartUpdate = 0;
        const CHART_UPDATE_INTERVAL = 1000; // Update chart every 1 second

        // Visible metric groups
        let visibleMetrics = {
            throughput: true,
            delay: true,
            jitter: true,
            loss: true,
            reordering: true
        };

        function initChart() {
            const ctx = document.getElementById('metrics-chart').getContext('2d');
            
            metricsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'time',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            time: {
                                displayFormats: {
                                    millisecond: 'HH:mm:ss.SSS',
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm:ss',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'yyyy-MM-dd HH:mm:ss.SSS'
                            },
                            ticks: {
                                source: 'data',
                                maxRotation: 45,
                                autoSkip: true
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Value'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 20,
                                font: {
                                    size: 10
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    if (context.length > 0) {
                                        const timestamp = context[0].parsed.x;
                                        const date = new Date(timestamp);
                                        return date.toISOString().replace('T', ' ').replace('Z', '');
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    animation: false
                }
            });
            
            updateChartDatasets();
        }

        function updateChartDatasets() {
            const datasets = [];
            const colors = {
                ipv4: { r: 33, g: 150, b: 243 },    // Blue
                ipv6: { r: 255, g: 152, b: 0 }       // Orange
            };

            const metricConfigs = [
                { key: 'throughput', name: 'Throughput', unit: 'KB/s', visible: visibleMetrics.throughput },
                { key: 'delay', name: 'Delay', unit: 'ms', visible: visibleMetrics.delay },
                { key: 'jitter', name: 'Jitter', unit: 'ms', visible: visibleMetrics.jitter },
                { key: 'loss', name: 'Loss', unit: '%', visible: visibleMetrics.loss },
                { key: 'reorder', name: 'Reorder', unit: '%', visible: visibleMetrics.reordering }
            ];

            const windows = [
                { key: '1s', dash: [], width: 2 }
            ];

            for (const metric of metricConfigs) {
                if (!metric.visible) continue;

                for (const window of windows) {
                    for (const [ipVersion, color] of Object.entries(colors)) {
                        const dataKey = `${metric.key}_${window.key}`;
                        const data = chartData[ipVersion][dataKey] || [];
                        
                        datasets.push({
                            label: `${ipVersion.toUpperCase()} ${metric.name} ${window.key} (${metric.unit})`,
                            data: data,
                            borderColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`,
                            backgroundColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`,
                            borderWidth: window.width,
                            borderDash: window.dash,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHitRadius: 5,
                            spanGaps: false
                        });
                    }
                }
            }

            if (metricsChart) {
                metricsChart.data.datasets = datasets;
                metricsChart.update('none');
            }
        }

        function toggleMetric(metricType) {
            visibleMetrics[metricType] = !visibleMetrics[metricType];
            updateChartDatasets();
        }

        function resetZoom() {
            if (metricsChart) {
                metricsChart.resetZoom();
            }
        }

        function addMetricsData(ipv4Metrics, ipv6Metrics) {
            const now = Date.now();
            
            // Only update chart every second to avoid performance issues
            if (now - lastChartUpdate < CHART_UPDATE_INTERVAL) {
                return;
            }
            lastChartUpdate = now;

            // Use milliseconds timestamp for Chart.js time scale
            chartData.timestamps.push(now);

            // Helper to convert bytes/sec to KB/sec
            const bytesToKB = (bytes) => bytes / 1024;

            // Add IPv4 metrics
            chartData.ipv4.throughput_1s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[0]) });
            chartData.ipv4.throughput_10s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[1]) });
            chartData.ipv4.throughput_60s.push({ x: now, y: bytesToKB(ipv4Metrics.s2c_throughput[2]) });
            chartData.ipv4.delay_1s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[0] });
            chartData.ipv4.delay_10s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[1] });
            chartData.ipv4.delay_60s.push({ x: now, y: ipv4Metrics.s2c_delay_avg[2] });
            chartData.ipv4.jitter_1s.push({ x: now, y: ipv4Metrics.s2c_jitter[0] });
            chartData.ipv4.jitter_10s.push({ x: now, y: ipv4Metrics.s2c_jitter[1] });
            chartData.ipv4.jitter_60s.push({ x: now, y: ipv4Metrics.s2c_jitter[2] });
            chartData.ipv4.loss_1s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[0] });
            chartData.ipv4.loss_10s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[1] });
            chartData.ipv4.loss_60s.push({ x: now, y: ipv4Metrics.s2c_loss_rate[2] });
            chartData.ipv4.reorder_1s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[0] });
            chartData.ipv4.reorder_10s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[1] });
            chartData.ipv4.reorder_60s.push({ x: now, y: ipv4Metrics.s2c_reorder_rate[2] });

            // Add IPv6 metrics
            chartData.ipv6.throughput_1s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[0]) });
            chartData.ipv6.throughput_10s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[1]) });
            chartData.ipv6.throughput_60s.push({ x: now, y: bytesToKB(ipv6Metrics.s2c_throughput[2]) });
            chartData.ipv6.delay_1s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[0] });
            chartData.ipv6.delay_10s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[1] });
            chartData.ipv6.delay_60s.push({ x: now, y: ipv6Metrics.s2c_delay_avg[2] });
            chartData.ipv6.jitter_1s.push({ x: now, y: ipv6Metrics.s2c_jitter[0] });
            chartData.ipv6.jitter_10s.push({ x: now, y: ipv6Metrics.s2c_jitter[1] });
            chartData.ipv6.jitter_60s.push({ x: now, y: ipv6Metrics.s2c_jitter[2] });
            chartData.ipv6.loss_1s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[0] });
            chartData.ipv6.loss_10s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[1] });
            chartData.ipv6.loss_60s.push({ x: now, y: ipv6Metrics.s2c_loss_rate[2] });
            chartData.ipv6.reorder_1s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[0] });
            chartData.ipv6.reorder_10s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[1] });
            chartData.ipv6.reorder_60s.push({ x: now, y: ipv6Metrics.s2c_reorder_rate[2] });

            // Limit data points to prevent memory issues
            if (chartData.timestamps.length > MAX_DATA_POINTS) {
                chartData.timestamps.shift();
                for (const ipVersion of ['ipv4', 'ipv6']) {
                    for (const key in chartData[ipVersion]) {
                        chartData[ipVersion][key].shift();
                    }
                }
            }

            // Update chart directly without transformation
            if (metricsChart) {
                updateChartDatasets();
                metricsChart.update('none');
            }
        }

        // Initialize chart when page loads
        window.addEventListener('load', () => {
            initChart();
        });

        // Make addMetricsData globally available
        window.addMetricsData = addMetricsData;
        
        // Traceroute visualization data structure
        let tracerouteData = {
            // Map of IP version -> connection_id -> array of hop objects
            // Each hop object: { hop: number, ip_addresses: Set<string>, rtts: Map<string, number[]>, messages: string[] }
            ipv4: {},
            ipv6: {}
        };
        
        // MTU tracking data structure
        // Map of IP version -> connection_id -> hop_number -> min_mtu
        // Stores the minimum MTU discovered for each hop on each connection
        let mtuData = {
            ipv4: {},
            ipv6: {}
        };
        
        // Function to add traceroute hop data
        function addTracerouteHop(hopData) {
            // Filter out "Probing hop" messages (placeholder messages)
            // This is a defensive measure in case old messages are still in flight
            // or if the server code is reverted temporarily
            if (hopData.message && hopData.message.includes("Probing hop")) {
                return; // Ignore placeholder messages
            }
            
            const connId = hopData.conn_id || 'default';
            const ipAddress = hopData.ip_address;
            
            // Track UDP address pairs for cross-checking
            if (hopData.original_src_port && hopData.original_dest_addr) {
                addConnectionUdpPair(connId, hopData.original_src_port, hopData.original_dest_addr);
            }
            
            // Determine IP version from the address
            let ipVersion = 'ipv4';
            if (ipAddress && ipAddress.includes(':')) {
                ipVersion = 'ipv6';
            }
            
            // Initialize connection if needed
            if (!tracerouteData[ipVersion][connId]) {
                tracerouteData[ipVersion][connId] = [];
            }
            
            // Find or create hop entry
            let hopEntry = tracerouteData[ipVersion][connId].find(h => h.hop === hopData.hop);
            if (!hopEntry) {
                hopEntry = {
                    hop: hopData.hop,
                    ip_addresses: new Set(),
                    rtts: new Map(),  // Map of IP -> array of RTT values
                    messages: []
                };
                tracerouteData[ipVersion][connId].push(hopEntry);
            }
            
            // Add IP address if present
            if (ipAddress) {
                hopEntry.ip_addresses.add(ipAddress);
                
                // Track RTT for this IP
                if (!hopEntry.rtts.has(ipAddress)) {
                    hopEntry.rtts.set(ipAddress, []);
                }
                hopEntry.rtts.get(ipAddress).push(hopData.rtt_ms);
            }
            
            // Add message if not already present
            if (hopData.message && !hopEntry.messages.includes(hopData.message)) {
                hopEntry.messages.push(hopData.message);
            }
            
            // Re-render the visualization
            renderTracerouteGraph();
        }
        
        // Function to add MTU hop data
        function addMtuHop(mtuHopData) {
            const connId = mtuHopData.conn_id || 'default';
            const hopNum = mtuHopData.hop;
            const mtuValue = mtuHopData.mtu;
            const ipAddress = mtuHopData.ip_address;
            
            // Determine IP version from the address
            let ipVersion = 'ipv4';
            if (ipAddress && ipAddress.includes(':')) {
                ipVersion = 'ipv6';
            }
            
            // For each MTU message about hop N, store the MTU for hop N-1
            // This is because the MTU value represents the link capacity TO hop N,
            // so it applies to the previous hop (N-1) in the path
            // MTU must be > 0 to be valid
            if (mtuValue != null && mtuValue > 0 && hopNum > 0) {
                const targetHop = hopNum - 1;
                
                // Initialize connection MTU tracking if needed
                if (!mtuData[ipVersion][connId]) {
                    mtuData[ipVersion][connId] = {};
                }
                
                // Get or initialize MTU for this specific hop (N-1)
                // Store the minimum MTU seen for this hop on this connection
                if (mtuData[ipVersion][connId][targetHop] === undefined) {
                    mtuData[ipVersion][connId][targetHop] = mtuValue;
                } else {
                    // Set to the smaller value (minimum MTU)
                    mtuData[ipVersion][connId][targetHop] = Math.min(mtuData[ipVersion][connId][targetHop], mtuValue);
                }
                
                // Re-render the visualization to show updated MTU data
                renderTracerouteGraph();
            }
        }
        
        // Function to clear traceroute data
        function clearTracerouteData() {
            tracerouteData.ipv4 = {};
            tracerouteData.ipv6 = {};
            mtuData.ipv4 = {};
            mtuData.ipv6 = {};
            renderTracerouteGraph();
        }
        
        // Function to render the traceroute graph
        function renderTracerouteGraph() {
            renderTracerouteGraphForVersion('ipv4');
            renderTracerouteGraphForVersion('ipv6');
        }
        
        function renderTracerouteGraphForVersion(ipVersion) {
            const graphContainer = document.getElementById(`traceroute-graph-${ipVersion}`);
            if (!graphContainer) return;
            
            const connections = tracerouteData[ipVersion];
            const connIds = Object.keys(connections);
            
            if (connIds.length === 0) {
                const versionLabel = ipVersion.toUpperCase();
                graphContainer.innerHTML = `<div style="text-align: center; color: #999; padding: 40px;">No ${versionLabel} traceroute data available.</div>`;
                return;
            }
            
            // Find max hop number across all connections
            let maxHop = 0;
            connIds.forEach(connId => {
                connections[connId].forEach(hop => {
                    if (hop.hop > maxHop) maxHop = hop.hop;
                });
            });
            
            // Build HTML for the graph
            let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
            
            // For each hop number, create a row
            for (let hopNum = 1; hopNum <= maxHop; hopNum++) {
                html += '<div style="display: flex; align-items: center; gap: 10px; padding: 5px 0;">';
                html += `<div style="min-width: 60px; font-weight: bold; color: #555;">Hop ${hopNum}:</div>`;
                html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; flex: 1;">';
                
                // Collect all hop entries at this hop across all connections
                const hopsAtThisLevel = [];
                connIds.forEach(connId => {
                    const hop = connections[connId].find(h => h.hop === hopNum);
                    if (hop) {
                        hopsAtThisLevel.push({ connId, hop });
                    }
                });
                
                if (hopsAtThisLevel.length === 0) {
                    html += '<div style="color: #999; font-style: italic;">No response</div>';
                } else {
                    // Group by unique IP addresses across all connections at this hop
                    const ipToConnections = new Map();
                    hopsAtThisLevel.forEach(({ connId, hop }) => {
                        hop.ip_addresses.forEach(ip => {
                            if (!ipToConnections.has(ip)) {
                                ipToConnections.set(ip, []);
                            }
                            ipToConnections.get(ip).push({ connId, hop });
                        });
                    });
                    
                    // Determine if there are multiple IPs for this hop (highlighting needed)
                    const hasMultipleIps = ipToConnections.size > 1;
                    
                    // Render each unique IP as a node
                    ipToConnections.forEach((connsForIp, ip) => {
                        const connCount = connsForIp.length;
                        
                        // Calculate average RTT for this IP
                        let allRtts = [];
                        connsForIp.forEach(({ hop }) => {
                            if (hop.rtts.has(ip)) {
                                allRtts = allRtts.concat(hop.rtts.get(ip));
                            }
                        });
                        const avgRtt = allRtts.length > 0 ? allRtts.reduce((a, b) => a + b, 0) / allRtts.length : 0;
                        
                        // Collect MTU values for this hop from all connections
                        const mtuValues = [];
                        connsForIp.forEach(({ connId }) => {
                            if (mtuData[ipVersion][connId] && mtuData[ipVersion][connId][hopNum]) {
                                mtuValues.push({
                                    connId: connId,
                                    mtu: mtuData[ipVersion][connId][hopNum]
                                });
                            }
                        });
                        
                        // Calculate MTU range (min-max) for display in box
                        let mtuRangeText = '';
                        if (mtuValues.length > 0) {
                            const mtuNumbers = mtuValues.map(m => m.mtu);
                            const minMtu = Math.min(...mtuNumbers);
                            const maxMtu = Math.max(...mtuNumbers);
                            if (minMtu === maxMtu) {
                                mtuRangeText = `MTU: ${minMtu}`;
                            } else {
                                mtuRangeText = `MTU: ${minMtu}-${maxMtu}`;
                            }
                        }
                        
                        // Create tooltip with literal newlines
                        const tooltipLines = [
                            `Hop ${hopNum}`,
                            `${ip}`,
                            ``,
                            `Connections (${connCount}):`
                        ];
                        connsForIp.forEach(({ connId, hop }) => {
                            const shortId = connId.substring(0, 8);
                            const rtts = hop.rtts.get(ip) || [];
                            const avgConnRtt = rtts.length > 0 ? rtts.reduce((a, b) => a + b, 0) / rtts.length : 0;
                            
                            // Find MTU for this connection if available
                            const connMtu = mtuValues.find(m => m.connId === connId);
                            const mtuText = connMtu ? ` MTU: ${connMtu.mtu}` : '';
                            
                            tooltipLines.push(`[${shortId}] RTT: ${avgConnRtt.toFixed(2)}ms${mtuText}`);
                        });
                        const tooltip = tooltipLines.join('\n');
                        
                        // Node styling
                        // Highlight if there are multiple IPs at this hop (ECMP path variation)
                        const nodeColor = hasMultipleIps ? '#FF5722' : (connCount === connIds.length ? '#4CAF50' : '#FF9800');
                        const borderStyle = hasMultipleIps ? 'solid' : (connCount === connIds.length ? 'solid' : 'dashed');
                        const borderWidth = hasMultipleIps ? '3px' : '2px';
                        
                        html += `<div style="
                            position: relative;
                            background: ${nodeColor};
                            color: white;
                            padding: 8px 12px;
                            border-radius: 6px;
                            border: ${borderWidth} ${borderStyle} ${nodeColor};
                            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                            cursor: help;
                            font-size: 12px;
                            white-space: nowrap;
                            transition: transform 0.2s, box-shadow 0.2s;
                        " title="${tooltip}" onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.3)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.2)';">
                            <div style="font-weight: bold;">${ip}</div>
                            <div style="font-size: 10px; opacity: 0.9;">${avgRtt.toFixed(1)}ms avg</div>
                            <div style="font-size: 9px; opacity: 0.8;">${connCount}/${connIds.length} conn</div>
                            ${mtuRangeText ? `<div style="font-size: 9px; opacity: 0.8;">${mtuRangeText}</div>` : ''}
                        </div>`;
                    });
                }
                
                html += '</div></div>';
            }
            
            html += '</div>';
            
            // Add legend
            html += `<div style="margin-top: 20px; padding: 10px; background: #f9f9f9; border-radius: 4px; font-size: 12px;">
                <strong>Legend:</strong>
                <span style="margin-left: 15px;">
                    <span style="display: inline-block; width: 12px; height: 12px; background: #4CAF50; border: 2px solid #4CAF50; border-radius: 2px; margin-right: 5px;"></span>
                    All connections pass through (solid border)
                </span>
                <span style="margin-left: 15px;">
                    <span style="display: inline-block; width: 12px; height: 12px; background: #FF9800; border: 2px dashed #FF9800; border-radius: 2px; margin-right: 5px;"></span>
                    Partial connections (dashed border)
                </span>
                <span style="margin-left: 15px;">
                    <span style="display: inline-block; width: 12px; height: 12px; background: #FF5722; border: 3px solid #FF5722; border-radius: 2px; margin-right: 5px;"></span>
                    Multiple IPs at this hop (path variation)
                </span>
            </div>`;
            
            graphContainer.innerHTML = html;
        }
        
        // Make traceroute functions globally available
        window.addTracerouteHop = addTracerouteHop;
        window.addMtuHop = addMtuHop;
        window.clearTracerouteData = clearTracerouteData;
        
        // Peer connections data structure
        // Maps: ipVersion -> connIndex -> { conn_id, local_address, remote_address, udp_pairs }
        let peerConnectionsData = {
            ipv4: {},
            ipv6: {}
        };
        
        // Track unique UDP address pairs per connection (conn_id -> Set of "src_port -> dest_addr" strings)
        let connectionUdpPairs = {};
        
        // Helper function to escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Function to add a UDP address pair to a connection
        function addConnectionUdpPair(connId, srcPort, destAddr) {
            // Filter out unset values (srcPort of 0 indicates unset since valid ephemeral ports are > 0)
            if (!connId || srcPort === undefined || srcPort === null || !destAddr) return;
            
            if (!connectionUdpPairs[connId]) {
                connectionUdpPairs[connId] = new Set();
            }
            
            const pairKey = `${srcPort} â†’ ${destAddr}`;
            const hadPair = connectionUdpPairs[connId].has(pairKey);
            connectionUdpPairs[connId].add(pairKey);
            
            // Re-render if we added a new pair
            if (!hadPair) {
                renderPeerConnectionsList();
            }
        }
        
        // Function to register a peer connection
        function registerPeerConnection(ipVersion, connIndex, connId, localAddress, remoteAddress) {
            peerConnectionsData[ipVersion][connIndex] = {
                conn_id: connId,
                local_address: localAddress || 'Unknown',
                remote_address: remoteAddress || 'Unknown'
            };
            
            // Initialize UDP pairs tracking for this connection
            if (!connectionUdpPairs[connId]) {
                connectionUdpPairs[connId] = new Set();
            }
            
            // Update the UI
            renderPeerConnectionsList();
            
            // Update the table title with connection ID
            updateConnectionTitle(ipVersion, connIndex, connId);
        }
        
        // Function to update peer connection addresses (called when WebRTC provides actual addresses)
        function updatePeerConnectionAddresses(ipVersion, connIndex, localAddress, remoteAddress) {
            if (peerConnectionsData[ipVersion] && peerConnectionsData[ipVersion][connIndex]) {
                const conn = peerConnectionsData[ipVersion][connIndex];
                let changed = false;
                
                if (localAddress && localAddress !== conn.local_address) {
                    conn.local_address = localAddress;
                    changed = true;
                }
                if (remoteAddress && remoteAddress !== conn.remote_address) {
                    conn.remote_address = remoteAddress;
                    changed = true;
                }
                
                // Only re-render if something changed
                if (changed) {
                    renderPeerConnectionsList();
                }
            }
        }
        
        // Function to clear peer connections data
        function clearPeerConnectionsData() {
            peerConnectionsData.ipv4 = {};
            peerConnectionsData.ipv6 = {};
            connectionUdpPairs = {};
            renderPeerConnectionsList();
        }
        
        // Function to update connection title with conn_id
        function updateConnectionTitle(ipVersion, connIndex, connId) {
            const shortConnId = connId.length > 8 ? connId.substring(0, 8) : connId;
            const connIdEl = document.getElementById(`${ipVersion}-${connIndex}-conn-id`);
            if (connIdEl) {
                connIdEl.textContent = `[${shortConnId}]`;
                connIdEl.title = `Full Connection ID: ${connId}`;
            }
        }
        
        // Function to render the peer connections list
        function renderPeerConnectionsList() {
            const container = document.getElementById('peer-connections-list');
            if (!container) return;
            
            const allConnections = [];
            
            // Collect IPv4 connections
            for (const [index, connInfo] of Object.entries(peerConnectionsData.ipv4)) {
                allConnections.push({
                    ipVersion: 'IPv4',
                    index: parseInt(index),
                    ...connInfo
                });
            }
            
            // Collect IPv6 connections
            for (const [index, connInfo] of Object.entries(peerConnectionsData.ipv6)) {
                allConnections.push({
                    ipVersion: 'IPv6',
                    index: parseInt(index),
                    ...connInfo
                });
            }
            
            if (allConnections.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #999; padding: 20px; border: 1px dashed #ccc; border-radius: 4px;">No active connections. Click "Analyze Network" to start.</div>';
                return;
            }
            
            // Sort by IP version then by index
            allConnections.sort((a, b) => {
                if (a.ipVersion !== b.ipVersion) {
                    return a.ipVersion === 'IPv4' ? -1 : 1;
                }
                return a.index - b.index;
            });
            
            let html = '';
            for (const conn of allConnections) {
                const shortConnId = conn.conn_id.length > 8 ? conn.conn_id.substring(0, 8) : conn.conn_id;
                const bgColor = conn.ipVersion === 'IPv4' ? '#e3f2fd' : '#fff3e0';
                const borderColor = conn.ipVersion === 'IPv4' ? '#2196F3' : '#FF9800';
                
                // Get UDP pairs for this connection
                const udpPairs = connectionUdpPairs[conn.conn_id] || new Set();
                const udpPairsArray = Array.from(udpPairs);
                
                let udpPairsHtml = '';
                if (udpPairsArray.length > 0) {
                    udpPairsHtml = `
                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px dashed ${borderColor};">
                        <div style="font-size: 11px; color: #666; margin-bottom: 4px;"><strong>UDP Pairs (src â†’ dest):</strong></div>
                        <div style="font-size: 10px; font-family: monospace; max-height: 60px; overflow-y: auto; background: rgba(255,255,255,0.5); padding: 4px; border-radius: 3px;">
                            ${udpPairsArray.map(pair => `<div style="margin: 1px 0;">${escapeHtml(pair)}</div>`).join('')}
                        </div>
                    </div>`;
                }
                
                html += `
                <div style="background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 8px; padding: 12px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: ${borderColor};">
                        ${escapeHtml(conn.ipVersion)} Connection #${conn.index + 1}
                    </div>
                    <div style="font-size: 13px; margin-bottom: 6px;">
                        <strong>Conn ID:</strong> <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;" title="${escapeHtml(conn.conn_id)}">${escapeHtml(shortConnId)}</code>
                    </div>
                    <div style="font-size: 12px; color: #555;">
                        <div><strong>Local:</strong> ${escapeHtml(conn.local_address)}</div>
                        <div><strong>Remote:</strong> ${escapeHtml(conn.remote_address)}</div>
                    </div>
                    ${udpPairsHtml}
                </div>`;
            }
            
            container.innerHTML = html;
        }
        
        // Make peer connection functions globally available
        window.registerPeerConnection = registerPeerConnection;
        window.updatePeerConnectionAddresses = updatePeerConnectionAddresses;
        window.clearPeerConnectionsData = clearPeerConnectionsData;
        
        // Function to generate metrics tables for multiple connections
        function generateMultiConnectionTables(connCount) {
            const container = document.getElementById('metrics-tables-container');
            if (!container) return;
            
            // If only 1 connection, use the default tables
            if (connCount <= 1) {
                document.getElementById('default-metrics').style.display = 'flex';
                return;
            }
            
            // Hide default metrics and create dynamic tables
            document.getElementById('default-metrics').style.display = 'none';
            
            // Clear any existing dynamic tables
            const existingDynamic = container.querySelectorAll('.dynamic-metrics');
            existingDynamic.forEach(el => el.remove());
            
            // Create a table for each connection pair (IPv4 + IPv6)
            for (let i = 0; i < connCount; i++) {
                const connDiv = document.createElement('div');
                connDiv.className = 'dual-stack-container dynamic-metrics';
                connDiv.style.marginBottom = '20px';
                connDiv.innerHTML = `
                    <div class="stack-column">
                        <h3>IPv4 Connection #${i + 1} <span id="ipv4-${i}-conn-id" style="font-size: 0.8em; color: #666;"></span></h3>
                        <table class="ipv4">
                            <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                            <tr><td>Throughput</td><td id="ipv4-${i}-s2c-tp-1">-</td><td id="ipv4-${i}-s2c-tp-10">-</td><td id="ipv4-${i}-s2c-tp-60">-</td></tr>
                            <tr><td>Delay (ms)</td><td id="ipv4-${i}-s2c-delay-1">-</td><td id="ipv4-${i}-s2c-delay-10">-</td><td id="ipv4-${i}-s2c-delay-60">-</td></tr>
                            <tr><td>Jitter (ms)</td><td id="ipv4-${i}-s2c-jitter-1">-</td><td id="ipv4-${i}-s2c-jitter-10">-</td><td id="ipv4-${i}-s2c-jitter-60">-</td></tr>
                            <tr><td>Loss Rate</td><td id="ipv4-${i}-s2c-loss-1">-</td><td id="ipv4-${i}-s2c-loss-10">-</td><td id="ipv4-${i}-s2c-loss-60">-</td></tr>
                            <tr><td>Reordering</td><td id="ipv4-${i}-s2c-reorder-1">-</td><td id="ipv4-${i}-s2c-reorder-10">-</td><td id="ipv4-${i}-s2c-reorder-60">-</td></tr>
                        </table>
                    </div>
                    <div class="stack-column">
                        <h3>IPv6 Connection #${i + 1} <span id="ipv6-${i}-conn-id" style="font-size: 0.8em; color: #666;"></span></h3>
                        <table class="ipv6">
                            <tr><th>Metric</th><th>1s</th><th>10s</th><th>60s</th></tr>
                            <tr><td>Throughput</td><td id="ipv6-${i}-s2c-tp-1">-</td><td id="ipv6-${i}-s2c-tp-10">-</td><td id="ipv6-${i}-s2c-tp-60">-</td></tr>
                            <tr><td>Delay (ms)</td><td id="ipv6-${i}-s2c-delay-1">-</td><td id="ipv6-${i}-s2c-delay-10">-</td><td id="ipv6-${i}-s2c-delay-60">-</td></tr>
                            <tr><td>Jitter (ms)</td><td id="ipv6-${i}-s2c-jitter-1">-</td><td id="ipv6-${i}-s2c-jitter-10">-</td><td id="ipv6-${i}-s2c-jitter-60">-</td></tr>
                            <tr><td>Loss Rate</td><td id="ipv6-${i}-s2c-loss-1">-</td><td id="ipv6-${i}-s2c-loss-10">-</td><td id="ipv6-${i}-s2c-loss-60">-</td></tr>
                            <tr><td>Reordering</td><td id="ipv6-${i}-s2c-reorder-1">-</td><td id="ipv6-${i}-s2c-reorder-10">-</td><td id="ipv6-${i}-s2c-reorder-60">-</td></tr>
                        </table>
                    </div>
                `;
                container.appendChild(connDiv);
            }
        }
        
        // Function to update metrics for a specific connection
        function updateConnectionMetrics(ipVersion, connIndex, metrics) {
            const prefix = `${ipVersion}-${connIndex}-s2c`;
            const setBytesToKB = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = (value / 1024).toFixed(2) + ' KB/s';
            };
            const setMs = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value.toFixed(2);
            };
            const setPercent = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value.toFixed(2) + '%';
            };
            
            setBytesToKB(`${prefix}-tp-1`, metrics.s2c_throughput[0]);
            setBytesToKB(`${prefix}-tp-10`, metrics.s2c_throughput[1]);
            setBytesToKB(`${prefix}-tp-60`, metrics.s2c_throughput[2]);
            setMs(`${prefix}-delay-1`, metrics.s2c_delay_avg[0]);
            setMs(`${prefix}-delay-10`, metrics.s2c_delay_avg[1]);
            setMs(`${prefix}-delay-60`, metrics.s2c_delay_avg[2]);
            setMs(`${prefix}-jitter-1`, metrics.s2c_jitter[0]);
            setMs(`${prefix}-jitter-10`, metrics.s2c_jitter[1]);
            setMs(`${prefix}-jitter-60`, metrics.s2c_jitter[2]);
            setPercent(`${prefix}-loss-1`, metrics.s2c_loss_rate[0]);
            setPercent(`${prefix}-loss-10`, metrics.s2c_loss_rate[1]);
            setPercent(`${prefix}-loss-60`, metrics.s2c_loss_rate[2]);
            setPercent(`${prefix}-reorder-1`, metrics.s2c_reorder_rate[0]);
            setPercent(`${prefix}-reorder-10`, metrics.s2c_reorder_rate[1]);
            setPercent(`${prefix}-reorder-60`, metrics.s2c_reorder_rate[2]);
        }
        
        // Make functions globally available
        window.generateMultiConnectionTables = generateMultiConnectionTables;
        window.updateConnectionMetrics = updateConnectionMetrics;
    </script>
    <script type="module">
        const errorEl = document.getElementById('error');
        const statusEl = document.getElementById('status');
        const analyzeNetworkBtn = document.getElementById('analyze-network-btn');
        const stopTestingBtn = document.getElementById('stop-testing-btn');
        const wakeLockStatusEl = document.getElementById('wake-lock-status');

        // Update button states based on testing status
        function updateButtonStates(isTesting) {
            analyzeNetworkBtn.disabled = isTesting;
            stopTestingBtn.disabled = !isTesting;
        }

        // Check if Wake Lock API is supported
        function checkWakeLockSupport() {
            if ('wakeLock' in navigator) {
                wakeLockStatusEl.textContent = 'ðŸ”“ Wake Lock: Ready';
                wakeLockStatusEl.className = '';
            } else {
                wakeLockStatusEl.textContent = 'âš ï¸ Wake Lock: Not Supported';
                wakeLockStatusEl.className = 'unsupported';
            }
        }

        // Call on page load
        checkWakeLockSupport();
        
        // Check capture status and update UI
        async function checkCaptureStatus() {
            const captureStatusEl = document.getElementById('capture-status');
            const downloadBtn = document.getElementById('download-pcap-btn');
            
            try {
                const response = await fetch('/api/capture/stats');
                if (response.ok) {
                    const data = await response.json();
                    if (data.enabled && data.stats) {
                        const stats = data.stats;
                        captureStatusEl.textContent = `Capture active: ${stats.packets_in_buffer} packets buffered (${stats.total_captured} total captured)`;
                        captureStatusEl.style.color = '#4CAF50';
                        downloadBtn.style.backgroundColor = '#4CAF50';
                        downloadBtn.style.pointerEvents = 'auto';
                        downloadBtn.style.opacity = '1';
                    } else {
                        captureStatusEl.textContent = 'Capture disabled (enable in server config)';
                        captureStatusEl.style.color = '#999';
                        downloadBtn.style.backgroundColor = '#ccc';
                        downloadBtn.style.pointerEvents = 'none';
                        downloadBtn.style.opacity = '0.6';
                    }
                } else {
                    captureStatusEl.textContent = 'Unable to check capture status';
                    captureStatusEl.style.color = '#f44336';
                }
            } catch (e) {
                captureStatusEl.textContent = 'Error checking capture status';
                captureStatusEl.style.color = '#f44336';
                console.error('Capture status check failed:', e);
            }
        }
        
        // Check tracing status and update UI
        async function checkTracingStatus() {
            const tracingStatusEl = document.getElementById('tracing-status');
            const downloadBtn = document.getElementById('download-tracing-btn');
            
            try {
                const response = await fetch('/api/tracing/stats');
                if (response.ok) {
                    const data = await response.json();
                    if (data.enabled) {
                        tracingStatusEl.textContent = `Tracing active: ${data.entries_in_buffer} entries buffered (max: ${data.max_entries})`;
                        tracingStatusEl.style.color = '#2196F3';
                        downloadBtn.style.backgroundColor = '#2196F3';
                        downloadBtn.style.pointerEvents = 'auto';
                        downloadBtn.style.opacity = '1';
                    } else {
                        tracingStatusEl.textContent = 'Tracing disabled (enable in server config)';
                        tracingStatusEl.style.color = '#999';
                        downloadBtn.style.backgroundColor = '#ccc';
                        downloadBtn.style.pointerEvents = 'none';
                        downloadBtn.style.opacity = '0.6';
                    }
                } else {
                    tracingStatusEl.textContent = 'Unable to check tracing status';
                    tracingStatusEl.style.color = '#f44336';
                }
            } catch (e) {
                tracingStatusEl.textContent = 'Error checking tracing status';
                tracingStatusEl.style.color = '#f44336';
                console.error('Tracing status check failed:', e);
            }
        }
        
        // Check capture status on page load
        checkCaptureStatus();
        
        // Check tracing status on page load
        checkTracingStatus();
        
        // Periodically update capture and tracing status (every 5 seconds)
        setInterval(checkCaptureStatus, 5000);
        setInterval(checkTracingStatus, 5000);

        // Wrap in async IIFE for better Safari compatibility
        (async () => {
            try {
                // Cache-busting timestamp
                const cacheBuster = Date.now();

                // Import the JS wrapper (without cache-busting query param for Safari compatibility)
                const module = await import('/public/pkg/wifi_verify_client.js');
                const { default: init, start_measurement, start_measurement_with_count, analyze_path, analyze_path_with_count, analyze_network, analyze_network_with_count, stop_testing, is_testing_active } = module;

                // Initialize WASM with explicit path and cache-busting
                // Pass the .wasm file path to init() for Safari compatibility
                await init(`/public/pkg/wifi_verify_client_bg.wasm?v=${cacheBuster}`);
                console.log('WASM module loaded successfully');
                statusEl.textContent = 'Ready';
                statusEl.className = '';
                
                // Get connection count from dropdown
                const getConnCount = () => {
                    const select = document.getElementById('conn-count');
                    return parseInt(select.value, 10) || 1;
                };

                window.analyzeNetwork = async function() {
                    statusEl.textContent = 'Starting network analysis...';
                    statusEl.className = '';
                    errorEl.textContent = '';
                    
                    // Update button states - disable analyze, enable stop
                    updateButtonStates(true);
                    
                    // Clear the server messages textarea
                    const serverMessagesEl = document.getElementById('server-messages');
                    if (serverMessagesEl) {
                        serverMessagesEl.value = '';
                    }
                    
                    // Clear traceroute visualization
                    if (window.clearTracerouteData) {
                        window.clearTracerouteData();
                    }
                    
                    // Clear peer connections data
                    if (window.clearPeerConnectionsData) {
                        window.clearPeerConnectionsData();
                    }
                    
                    const connCount = getConnCount();
                    console.log(`Starting network analysis with ${connCount} connections per address family`);
                    
                    // Generate dynamic tables for multi-connection display
                    if (window.generateMultiConnectionTables) {
                        window.generateMultiConnectionTables(connCount);
                    }

                    try {
                        // Update status to show phase 1 (traceroute)
                        statusEl.textContent = `Phase 1: Analyzing network paths (traceroute) with ${connCount} connection(s)...`;
                        statusEl.className = 'running';
                        
                        // Update wake lock status
                        if ('wakeLock' in navigator) {
                            wakeLockStatusEl.textContent = 'ðŸ”’ Wake Lock: Active';
                            wakeLockStatusEl.className = 'active';
                        }
                        
                        // Start the combined analysis
                        await analyze_network_with_count(connCount);
                        
                        // Update UI to show measurements are now running
                        statusEl.textContent = `Phase 2: Running network measurements with ${connCount} connection(s)...`;
                        statusEl.className = 'running';
                        
                    } catch (e) {
                        const errMsg = 'Network analysis error: ' + (e.message || e);
                        statusEl.textContent = 'Error';
                        statusEl.className = 'error';
                        errorEl.textContent = errMsg;
                        console.error('Network analysis error:', e);
                        
                        // Update button states - enable analyze, disable stop
                        updateButtonStates(false);
                        
                        // Update wake lock status
                        if ('wakeLock' in navigator) {
                            wakeLockStatusEl.textContent = 'ðŸ”“ Wake Lock: Ready';
                            wakeLockStatusEl.className = '';
                        }
                    }
                };
                
                // Stop testing function
                window.stopTesting = function() {
                    console.log('Stopping network testing...');
                    
                    try {
                        // Call the WASM stop_testing function
                        stop_testing();
                        
                        // Update UI
                        statusEl.textContent = 'Testing stopped';
                        statusEl.className = '';
                        
                        // Update button states - enable analyze, disable stop
                        updateButtonStates(false);
                        
                        // Update wake lock status
                        if ('wakeLock' in navigator) {
                            wakeLockStatusEl.textContent = 'ðŸ”“ Wake Lock: Ready';
                            wakeLockStatusEl.className = '';
                        }
                        
                        console.log('Testing stopped successfully');
                    } catch (e) {
                        console.error('Error stopping testing:', e);
                        errorEl.textContent = 'Error stopping testing: ' + (e.message || e);
                    }
                };
            } catch (e) {
                const errMsg = 'Failed to load WASM module: ' + (e.message || e);
                statusEl.textContent = 'Failed to load';
                statusEl.className = 'error';
                errorEl.textContent = errMsg;
                console.error('WASM load error:', e);
                console.error('Full error:', e.stack);

                window.analyzeNetwork = function() {
                    alert('WASM module failed to load. Please refresh the page.');
                };
            }
        })();
    </script>
</body>
</html>
