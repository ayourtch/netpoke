use crate::data_channels;
use crate::state::AppState;
use crate::webrtc_manager;
use axum::{extract::State, http::StatusCode, Json};
use common::{get_candidate_ip_version, is_name_based_candidate, IpFamily};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use webrtc::ice::candidate::CandidatePairState;
use webrtc::ice_transport::ice_candidate::RTCIceCandidateInit;
use webrtc::peer_connection::peer_connection_state::RTCPeerConnectionState;
use webrtc::stats::StatsReportType;

/// Filter SDP to remove ICE candidates of the wrong IP version or name-based addresses
///
/// Name-based candidates (e.g., mDNS xxx.local) are always filtered out.
/// If an IP version is specified, candidates of the wrong IP version are also filtered.
fn filter_sdp_candidates(sdp: &str, ip_version: Option<&String>) -> String {
    let mut filtered_lines = Vec::new();

    for line in sdp.lines() {
        if line.starts_with("a=candidate:") {
            // Convert SDP line format (a=candidate:...) to candidate format (candidate:...)
            // by stripping the "a=" prefix for use with shared utility functions
            let candidate_str = &line[2..]; // Remove "a=" prefix

            // First, filter out name-based candidates (e.g., xxx.local mDNS)
            if is_name_based_candidate(candidate_str) {
                tracing::debug!(
                    "Filtering out name-based (mDNS) candidate from SDP: {}",
                    line
                );
                continue;
            }

            // Check IP version if specified
            if let Some(expected_version) = ip_version {
                if let Some(detected_version) = get_candidate_ip_version(candidate_str) {
                    if detected_version.eq_ignore_ascii_case(expected_version) {
                        // Keep this candidate
                        filtered_lines.push(line);
                        tracing::debug!("Keeping {} candidate in SDP: {}", detected_version, line);
                    } else {
                        // Filter out this candidate
                        tracing::debug!(
                            "Filtering out {} candidate from SDP for {} connection: {}",
                            detected_version,
                            expected_version,
                            line
                        );
                    }
                } else {
                    // Unknown format, keep it
                    filtered_lines.push(line);
                }
            } else {
                // No IP version filter specified, keep all non-mDNS candidates
                filtered_lines.push(line);
            }
        } else {
            // Not a candidate line, keep it
            filtered_lines.push(line);
        }
    }

    filtered_lines.join("\r\n") + "\r\n"
}

#[derive(Debug, Deserialize)]
pub struct SignalingStartRequest {
    pub sdp: String,
    pub parent_client_id: Option<String>, // For grouping multiple sessions
    pub ip_version: Option<String>,       // "ipv4" or "ipv6"
    pub mode: Option<String>,             // "measurement" or "traceroute"
    /// Connection ID (UUID) for multi-path ECMP testing
    /// Generated by client, used to identify the connection
    #[serde(default)]
    pub conn_id: String,
}

#[derive(Debug, Serialize)]
pub struct SignalingStartResponse {
    pub client_id: String,
    pub parent_client_id: Option<String>,
    pub ip_version: Option<String>,
    pub sdp: String,
    /// Connection ID (UUID) for multi-path ECMP testing
    pub conn_id: String,
}

#[derive(Debug, Deserialize)]
pub struct IceCandidateRequest {
    pub client_id: String,
    pub candidate: String,
}

pub async fn signaling_start(
    State(state): State<AppState>,
    Json(req): Json<SignalingStartRequest>,
) -> Result<Json<SignalingStartResponse>, StatusCode> {
    tracing::info!("Received signaling start request: {:?}", &req);
    tracing::info!("SDP: {}", &req.sdp);
    tracing::info!("IP Version: {:?}, conn_id: {}", req.ip_version, req.conn_id);

    // Convert ip_version string to IpFamily for peer connection filtering.
    // IpFamily::from_str_loose accepts "ipv4", "4", "v4" for IPv4, "ipv6", "6", "v6" for IPv6,
    // and defaults to IpFamily::Both for any other value.
    let ip_family = req.ip_version.as_ref().map(|v| IpFamily::from_str_loose(v));

    // Create peer connection with IP family filtering
    let peer = webrtc_manager::create_peer_connection(ip_family)
        .await
        .map_err(|e| {
            tracing::error!("Failed to create peer connection: {}", e);
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    let client_id = uuid::Uuid::new_v4().to_string();

    // Use provided conn_id or generate a new one
    let conn_id = if req.conn_id.is_empty() {
        uuid::Uuid::new_v4().to_string()
    } else {
        req.conn_id.clone()
    };

    tracing::info!("Created peer connection: {:?} ...", &peer);

    // Use provided parent_client_id or create a new one
    let parent_client_id = req.parent_client_id.unwrap_or_else(|| client_id.clone());

    let data_channels = Arc::new(tokio::sync::RwLock::new(crate::state::DataChannels::new()));
    let metrics = Arc::new(tokio::sync::RwLock::new(common::ClientMetrics::default()));
    let measurement_state = Arc::new(tokio::sync::RwLock::new(
        crate::state::MeasurementState::new(),
    ));
    let ice_candidates = Arc::new(tokio::sync::Mutex::new(std::collections::VecDeque::new()));
    let peer_address = Arc::new(tokio::sync::Mutex::new(None::<(String, u16)>));

    let session = Arc::new(crate::state::ClientSession {
        id: client_id.clone(),
        parent_id: Some(parent_client_id.clone()),
        ip_version: req.ip_version.clone(),
        mode: req.mode.clone(),
        conn_id: conn_id.clone(),
        survey_session_id: Arc::new(tokio::sync::RwLock::new(String::new())),
        peer_connection: peer.clone(),
        data_channels,
        metrics,
        measurement_state,
        connected_at: std::time::Instant::now(),
        ice_candidates: ice_candidates.clone(),
        peer_address: peer_address.clone(),
        packet_tracker: state.packet_tracker.clone(), // Share global packet tracker
        icmp_error_count: Arc::new(tokio::sync::Mutex::new(0)),
        last_icmp_error: Arc::new(tokio::sync::Mutex::new(None)),
        capture_service: state.capture_service.clone(), // For survey-specific pcap
        keylog_service: state.keylog_service.clone(),   // For DTLS key storage
    });

    // Set up data channel handlers
    data_channels::setup_data_channel_handlers(&peer, session.clone()).await;
    tracing::info!("data channels setup done for {:?} ...", &peer);

    // Set up ICE candidate handler to send candidates back to client
    let client_id_for_ice = client_id.clone();
    let ice_candidates_for_handler = session.ice_candidates.clone();
    let ip_version_for_filter = req.ip_version.clone();
    peer.on_ice_candidate(Box::new(move |candidate| {
        if let Some(c) = candidate {
            tracing::info!("Server ICE candidate gathered for client {}", client_id_for_ice);

            // Extract the IP address from the candidate
            let candidate_address = c.address.clone();

            if let Ok(candidate_json) = serde_json::to_string(&c) {
                let candidates = ice_candidates_for_handler.clone();
                let ip_version_filter = ip_version_for_filter.clone();
                let client_id = client_id_for_ice.clone();

                tokio::spawn(async move {
                    // First, filter out name-based (mDNS) candidates
                    let should_store = if candidate_address.ends_with(".local") {
                        tracing::debug!("Server filtering out name-based (mDNS) candidate for client {}: {}",
                            client_id, candidate_address);
                        false
                    } else if let Some(ref expected_version) = ip_version_filter {
                        // Filter candidates by IP version if specified
                        // Check if address is IPv4 or IPv6
                        let detected_version = if candidate_address.contains(':') {
                            "ipv6"
                        } else if candidate_address.contains('.') {
                            "ipv4"
                        } else {
                            ""
                        };

                        if !detected_version.is_empty() {
                            let matches = detected_version.eq_ignore_ascii_case(expected_version);
                            if matches {
                                tracing::info!("Server storing {} candidate for client {}: {}",
                                    detected_version, client_id, candidate_address);
                            } else {
                                tracing::debug!("Server filtering out {} candidate for {} connection (client {}): {}",
                                    detected_version, expected_version, client_id, candidate_address);
                            }
                            matches
                        } else {
                            // Unable to determine version, store it anyway
                            tracing::debug!("Unable to determine server candidate IP version for client {}, storing anyway: {}",
                                client_id, candidate_address);
                            true
                        }
                    } else {
                        // No IP version filter specified, store all candidates
                        tracing::debug!("No IP version filter for client {}, storing candidate: {}",
                            client_id, candidate_address);
                        true
                    };

                    if should_store {
                        let mut candidates = candidates.lock().await;
                        candidates.push_back(candidate_json);
                        tracing::debug!("Stored ICE candidate in VecDeque (total: {})", candidates.len());
                    }

                    // Note: We DON'T extract peer address from server's own ICE candidates.
                    // The peer address comes from the remote (client) candidate, which we'll
                    // get from WebRTC stats once the connection is established.
                });
            }
        }
        Box::pin(async {})
    }));

    // Set up connection state change handler to populate peer address
    let session_for_state = session.clone();
    peer.on_peer_connection_state_change(Box::new(move |state: RTCPeerConnectionState| {
        let session = session_for_state.clone();
        Box::pin(async move {
            tracing::info!(
                "Peer connection state changed to {:?} for session {}",
                state,
                session.id
            );

            // When connection becomes Connected, fetch stats to get peer address
            if state == RTCPeerConnectionState::Connected {
                tracing::info!(
                    "Connection established for session {}, fetching peer address from stats",
                    session.id
                );

                // Get stats to find the peer address
                let stats_report = session.peer_connection.get_stats().await;

                // Find the selected candidate pair
                for stat in stats_report.reports.values() {
                    if let StatsReportType::CandidatePair(pair) = stat {
                        // Look for succeeded or nominated in-progress pairs
                        if pair.state == CandidatePairState::Succeeded
                            || (pair.state == CandidatePairState::InProgress && pair.nominated)
                        {
                            // Find the remote candidate by ID to get the IP address
                            for candidate_stat in stats_report.reports.values() {
                                if let StatsReportType::RemoteCandidate(candidate) = candidate_stat
                                {
                                    if candidate.id == pair.remote_candidate_id {
                                        let peer_ip = candidate.ip.clone();
                                        let peer_port = candidate.port;

                                        tracing::info!(
                                            "Found peer address for session {}: {}:{}",
                                            session.id,
                                            peer_ip,
                                            peer_port
                                        );

                                        // Store the peer address
                                        let mut stored_peer = session.peer_address.lock().await;
                                        *stored_peer = Some((peer_ip.clone(), peer_port));

                                        tracing::info!(
                                            "Stored peer address for session {}: {}:{}",
                                            session.id,
                                            peer_ip,
                                            peer_port
                                        );
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }

                tracing::warn!(
                    "Could not find peer address in stats for session {}",
                    session.id
                );
            }
        })
    }));

    // Handle offer and create answer
    let answer_sdp = match webrtc_manager::handle_offer(&peer, req.sdp).await {
        Ok(sdp) => sdp,
        Err(e) => {
            tracing::error!("Failed to handle offer: {}", e);
            // Send the peer connection to the cleanup task to prevent resource leak
            // (spawned tasks, UDP sockets, ICE agent loops)
            if let Err(send_err) = state.peer_cleanup_sender.send(peer) {
                tracing::warn!("Failed to send peer connection for cleanup: {}", send_err);
            }
            return Err(StatusCode::INTERNAL_SERVER_ERROR);
        }
    };

    tracing::info!("start the filtering ...");
    // Filter SDP candidates based on IP version
    let filtered_sdp = filter_sdp_candidates(&answer_sdp, req.ip_version.as_ref());
    tracing::info!(
        "Filtered SDP for {:?} connection, original candidates: {}, filtered candidates: {}",
        req.ip_version,
        answer_sdp.matches("a=candidate:").count(),
        filtered_sdp.matches("a=candidate:").count()
    );

    {
        use tokio::time::{timeout, Duration};

        tracing::info!("Inserting client....");
        let mut clts = match timeout(Duration::from_secs(5), state.clients.write("signaling")).await
        {
            Ok(g) => g,
            Err(_) => {
                state.clients.dump_locations();
                tracing::error!(
                    "PANIC! Deadlock backtrace:\n{}",
                    std::backtrace::Backtrace::force_capture()
                );
                return Err(StatusCode::INTERNAL_SERVER_ERROR);
            }
        };

        // let mut clts = state.clients.write().await;
        clts.insert(client_id.clone(), session);
        drop(clts);
        tracing::info!("Inserted client OK....");
    }

    let response = SignalingStartResponse {
        client_id,
        parent_client_id: Some(parent_client_id),
        ip_version: req.ip_version,
        sdp: filtered_sdp,
        conn_id,
    };
    tracing::info!("RESPONSE: {:?}", &response);

    Ok(Json(response))
}

pub async fn ice_candidate(
    State(state): State<AppState>,
    Json(req): Json<IceCandidateRequest>,
) -> Result<StatusCode, StatusCode> {
    tracing::info!("Received ICE candidate for client {}", req.client_id);
    tracing::debug!("ICE candidate data: {}", &req.candidate);

    let clients = state.clients.read("ice_candidate").await;
    let session = clients.get(&req.client_id).ok_or(StatusCode::NOT_FOUND)?;

    // Parse and add ICE candidate
    let candidate_init: RTCIceCandidateInit = match serde_json::from_str(&req.candidate) {
        Ok(val) => val,
        Err(e) => {
            tracing::error!("Failed to parse ICE candidate JSON: {}", e);
            return Err(StatusCode::BAD_REQUEST);
        }
    };

    // Filter candidate by IP version if session has one specified
    // Also filter out name-based (mDNS) candidates
    let candidate_str = &candidate_init.candidate;
    let should_add = if is_name_based_candidate(candidate_str) {
        // Filter out name-based (mDNS) candidates
        tracing::debug!(
            "Server filtering out name-based (mDNS) candidate from client {}: {}",
            req.client_id,
            candidate_str
        );
        false
    } else if let Some(ref expected_version) = session.ip_version {
        if let Some(detected_version) = get_candidate_ip_version(candidate_str) {
            let matches = detected_version.eq_ignore_ascii_case(expected_version);
            if matches {
                tracing::info!(
                    "Server accepting {} candidate from client {}: {}",
                    detected_version,
                    req.client_id,
                    candidate_str
                );
            } else {
                tracing::info!(
                    "Server rejecting {} candidate for {} connection (client {}): {}",
                    detected_version,
                    expected_version,
                    req.client_id,
                    candidate_str
                );
            }
            matches
        } else {
            // Unable to determine version, accept it anyway
            tracing::debug!("Unable to determine client candidate IP version for client {}, accepting anyway: {}",
                req.client_id, candidate_str);
            true
        }
    } else {
        // No IP version filter specified, accept all candidates
        true
    };

    if should_add {
        session
            .peer_connection
            .add_ice_candidate(candidate_init)
            .await
            .map_err(|e| {
                tracing::error!("Failed to add ICE candidate: {}", e);
                StatusCode::INTERNAL_SERVER_ERROR
            })?;
        Ok(StatusCode::OK)
    } else {
        // Return OK even though we filtered it out, to avoid breaking client flow
        tracing::debug!(
            "Filtered out candidate for client {}, returning OK",
            req.client_id
        );
        Ok(StatusCode::OK)
    }
}

pub async fn get_ice_candidates(
    State(state): State<AppState>,
    Json(req): Json<IceCandidateRequest>,
) -> Result<Json<Vec<String>>, StatusCode> {
    let clients = state.clients.read("get_ice_candidates").await;
    let session = clients.get(&req.client_id).ok_or(StatusCode::NOT_FOUND)?;

    // Drain all pending ICE candidates
    let mut candidates = session.ice_candidates.lock().await;
    let ice_candidates: Vec<String> = candidates.drain(..).collect();

    tracing::debug!(
        "Returning {} ICE candidates to client {}",
        ice_candidates.len(),
        req.client_id
    );

    Ok(Json(ice_candidates))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signaling_request_deserialization() {
        let json = r#"{"sdp": "test-sdp"}"#;
        let req: SignalingStartRequest = serde_json::from_str(json).unwrap();
        assert_eq!(req.sdp, "test-sdp");
    }

    #[test]
    fn test_signaling_response_serialization() {
        let resp = SignalingStartResponse {
            client_id: "test-123".to_string(),
            parent_client_id: None,
            ip_version: Some("ipv4".to_string()),
            sdp: "test-answer".to_string(),
            conn_id: "test-conn-id".to_string(),
        };
        let json = serde_json::to_string(&resp).unwrap();
        assert!(json.contains("test-123"));
        assert!(json.contains("ipv4"));
    }

    #[test]
    fn test_filter_sdp_candidates_removes_mdns_without_ip_version() {
        // SDP with mDNS candidate should have it removed even without IP version filter
        let sdp = "v=0\r\n\
                   o=- 1234567890 1 IN IP4 127.0.0.1\r\n\
                   s=-\r\n\
                   a=candidate:1234567890 1 udp 2122260223 abc123.local 54321 typ host\r\n\
                   a=candidate:1234567891 1 udp 2122260222 192.168.1.100 54322 typ host\r\n\
                   a=end-of-candidates\r\n";

        let filtered = filter_sdp_candidates(sdp, None);

        // mDNS candidate should be removed
        assert!(!filtered.contains("abc123.local"));
        // IPv4 candidate should remain
        assert!(filtered.contains("192.168.1.100"));
        // Non-candidate lines should remain
        assert!(filtered.contains("v=0"));
        assert!(filtered.contains("a=end-of-candidates"));
    }

    #[test]
    fn test_filter_sdp_candidates_filters_by_ip_version() {
        let sdp = "v=0\r\n\
                   o=- 1234567890 1 IN IP4 127.0.0.1\r\n\
                   s=-\r\n\
                   a=candidate:1234567890 1 udp 2122260223 abc123.local 54321 typ host\r\n\
                   a=candidate:1234567891 1 udp 2122260222 192.168.1.100 54322 typ host\r\n\
                   a=candidate:1234567892 1 udp 2122260221 2001:db8::1 54323 typ host\r\n\
                   a=end-of-candidates\r\n";

        // Filter for IPv4 only
        let filtered_ipv4 = filter_sdp_candidates(sdp, Some(&"ipv4".to_string()));
        assert!(!filtered_ipv4.contains("abc123.local")); // mDNS removed
        assert!(filtered_ipv4.contains("192.168.1.100")); // IPv4 kept
        assert!(!filtered_ipv4.contains("2001:db8::1")); // IPv6 removed

        // Filter for IPv6 only
        let filtered_ipv6 = filter_sdp_candidates(sdp, Some(&"ipv6".to_string()));
        assert!(!filtered_ipv6.contains("abc123.local")); // mDNS removed
        assert!(!filtered_ipv6.contains("192.168.1.100")); // IPv4 removed
        assert!(filtered_ipv6.contains("2001:db8::1")); // IPv6 kept
    }
}
